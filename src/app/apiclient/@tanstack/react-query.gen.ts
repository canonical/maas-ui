// This file is auto-generated by @hey-api/openapi-ts

import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query";

import { client as _heyApiClient } from "../client.gen";
import {
  type Options,
  accessToken,
  login,
  listEvents,
  listDomains,
  createDomain,
  deleteDomain,
  getDomain,
  getDomainRrsets,
  listFabrics,
  createFabric,
  deleteFabric,
  getFabric,
  updateFabric,
  listInterfaces,
  listFabricVlanSubnetIprange,
  createFabricVlanSubnetIprange,
  deleteFabricVlanSubnetIprange,
  updateFabricVlanSubnetIprange,
  getFabricVlanSubnetIprange,
  getMachinePowerParameters,
  listMachinePciDevices,
  listMachineUsbDevices,
  listMachines,
  listFabricVlanSubnetReservedIps,
  createFabricVlanSubnetReservedIp,
  deleteFabricVlanSubnetReservedIp,
  updateFabricVlanSubnetReservedIp,
  getFabricVlanSubnetReservedIp,
  listResourcePools,
  createResourcePool,
  deleteResourcePool,
  getResourcePool,
  updateResourcePool,
  listResourcePoolsWithSummary,
  listSpaces,
  createSpace,
  deleteSpace,
  getSpace,
  updateSpace,
  listUserSshkeys,
  createUserSshkeys,
  deleteUserSshkey,
  getUserSshkey,
  importUserSshkeys,
  getUserSslkeys,
  createUserSslkey,
  deleteUserSslkey,
  getUserSslkey,
  listFabricVlanSubnets,
  createFabricVlanSubnet,
  deleteFabricVlanSubnet,
  updateFabricVlanSubnet,
  getFabricVlanSubnet,
  getUserInfo,
  listUsers,
  createUser,
  deleteUser,
  getUser,
  updateUser,
  listFabricVlans,
  createFabricVlan,
  deleteFabricVlan,
  getFabricVlan,
  updateFabricVlan,
  listZones,
  createZone,
  deleteZone,
  getZone,
  updateZone,
  listZonesWithSummary,
} from "../sdk.gen";
import type {
  AccessTokenData,
  LoginData,
  LoginError,
  LoginResponse,
  ListEventsData,
  ListEventsError,
  ListEventsResponse,
  ListDomainsData,
  ListDomainsError,
  ListDomainsResponse,
  CreateDomainData,
  CreateDomainError,
  CreateDomainResponse,
  DeleteDomainData,
  DeleteDomainError,
  DeleteDomainResponse,
  GetDomainData,
  GetDomainRrsetsData,
  ListFabricsData,
  ListFabricsError,
  ListFabricsResponse,
  CreateFabricData,
  CreateFabricError,
  CreateFabricResponse,
  DeleteFabricData,
  DeleteFabricError,
  DeleteFabricResponse,
  GetFabricData,
  UpdateFabricData,
  UpdateFabricError,
  UpdateFabricResponse,
  ListInterfacesData,
  ListInterfacesError,
  ListInterfacesResponse,
  ListFabricVlanSubnetIprangeData,
  ListFabricVlanSubnetIprangeError,
  ListFabricVlanSubnetIprangeResponse,
  CreateFabricVlanSubnetIprangeData,
  CreateFabricVlanSubnetIprangeError,
  CreateFabricVlanSubnetIprangeResponse,
  DeleteFabricVlanSubnetIprangeData,
  DeleteFabricVlanSubnetIprangeError,
  DeleteFabricVlanSubnetIprangeResponse,
  UpdateFabricVlanSubnetIprangeData,
  UpdateFabricVlanSubnetIprangeError,
  UpdateFabricVlanSubnetIprangeResponse,
  GetFabricVlanSubnetIprangeData,
  GetMachinePowerParametersData,
  ListMachinePciDevicesData,
  ListMachinePciDevicesError,
  ListMachinePciDevicesResponse,
  ListMachineUsbDevicesData,
  ListMachineUsbDevicesError,
  ListMachineUsbDevicesResponse,
  ListMachinesData,
  ListMachinesError,
  ListMachinesResponse,
  ListFabricVlanSubnetReservedIpsData,
  ListFabricVlanSubnetReservedIpsError,
  ListFabricVlanSubnetReservedIpsResponse,
  CreateFabricVlanSubnetReservedIpData,
  CreateFabricVlanSubnetReservedIpError,
  CreateFabricVlanSubnetReservedIpResponse,
  DeleteFabricVlanSubnetReservedIpData,
  DeleteFabricVlanSubnetReservedIpError,
  DeleteFabricVlanSubnetReservedIpResponse,
  UpdateFabricVlanSubnetReservedIpData,
  UpdateFabricVlanSubnetReservedIpError,
  UpdateFabricVlanSubnetReservedIpResponse,
  GetFabricVlanSubnetReservedIpData,
  ListResourcePoolsData,
  ListResourcePoolsError,
  ListResourcePoolsResponse,
  CreateResourcePoolData,
  CreateResourcePoolError,
  CreateResourcePoolResponse,
  DeleteResourcePoolData,
  DeleteResourcePoolError,
  DeleteResourcePoolResponse,
  GetResourcePoolData,
  UpdateResourcePoolData,
  UpdateResourcePoolError,
  UpdateResourcePoolResponse,
  ListResourcePoolsWithSummaryData,
  ListResourcePoolsWithSummaryError,
  ListResourcePoolsWithSummaryResponse,
  ListSpacesData,
  ListSpacesError,
  ListSpacesResponse,
  CreateSpaceData,
  CreateSpaceError,
  CreateSpaceResponse,
  DeleteSpaceData,
  DeleteSpaceError,
  DeleteSpaceResponse,
  GetSpaceData,
  UpdateSpaceData,
  UpdateSpaceError,
  UpdateSpaceResponse,
  ListUserSshkeysData,
  ListUserSshkeysError,
  ListUserSshkeysResponse,
  CreateUserSshkeysData,
  CreateUserSshkeysError,
  CreateUserSshkeysResponse,
  DeleteUserSshkeyData,
  DeleteUserSshkeyError,
  DeleteUserSshkeyResponse,
  GetUserSshkeyData,
  ImportUserSshkeysData,
  ImportUserSshkeysError,
  ImportUserSshkeysResponse,
  GetUserSslkeysData,
  GetUserSslkeysError,
  GetUserSslkeysResponse,
  CreateUserSslkeyData,
  CreateUserSslkeyError,
  CreateUserSslkeyResponse,
  DeleteUserSslkeyData,
  DeleteUserSslkeyError,
  DeleteUserSslkeyResponse,
  GetUserSslkeyData,
  ListFabricVlanSubnetsData,
  ListFabricVlanSubnetsError,
  ListFabricVlanSubnetsResponse,
  CreateFabricVlanSubnetData,
  CreateFabricVlanSubnetError,
  CreateFabricVlanSubnetResponse,
  DeleteFabricVlanSubnetData,
  DeleteFabricVlanSubnetError,
  DeleteFabricVlanSubnetResponse,
  UpdateFabricVlanSubnetData,
  UpdateFabricVlanSubnetError,
  UpdateFabricVlanSubnetResponse,
  GetFabricVlanSubnetData,
  GetUserInfoData,
  ListUsersData,
  ListUsersError,
  ListUsersResponse,
  CreateUserData,
  CreateUserError,
  CreateUserResponse,
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  ListFabricVlansData,
  ListFabricVlansError,
  ListFabricVlansResponse,
  CreateFabricVlanData,
  CreateFabricVlanError,
  CreateFabricVlanResponse,
  DeleteFabricVlanData,
  DeleteFabricVlanError,
  DeleteFabricVlanResponse,
  GetFabricVlanData,
  UpdateFabricVlanData,
  UpdateFabricVlanError,
  UpdateFabricVlanResponse,
  ListZonesData,
  ListZonesError,
  ListZonesResponse,
  CreateZoneData,
  CreateZoneError,
  CreateZoneResponse,
  DeleteZoneData,
  DeleteZoneError,
  DeleteZoneResponse,
  GetZoneData,
  UpdateZoneData,
  UpdateZoneError,
  UpdateZoneResponse,
  ListZonesWithSummaryData,
  ListZonesWithSummaryError,
  ListZonesWithSummaryResponse,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const accessTokenQueryKey = (options?: Options<AccessTokenData>) =>
  createQueryKey("accessToken", options);

export const accessTokenOptions = (options?: Options<AccessTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await accessToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: accessTokenQueryKey(options),
  });
};

export const loginQueryKey = (options: Options<LoginData>) =>
  createQueryKey("login", options);

export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginQueryKey(options),
  });
};

export const loginMutation = (options?: Partial<Options<LoginData>>) => {
  const mutationOptions: UseMutationOptions<
    LoginResponse,
    LoginError,
    Options<LoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await login({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventsQueryKey = (options?: Options<ListEventsData>) =>
  createQueryKey("listEvents", options);

export const listEventsOptions = (options?: Options<ListEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventsQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = queryKey[0];
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listEventsInfiniteQueryKey = (
  options?: Options<ListEventsData>
): QueryKey<Options<ListEventsData>> =>
  createQueryKey("listEvents", options, true);

export const listEventsInfiniteOptions = (
  options?: Options<ListEventsData>
) => {
  return infiniteQueryOptions<
    ListEventsResponse,
    ListEventsError,
    InfiniteData<ListEventsResponse>,
    QueryKey<Options<ListEventsData>>,
    | number
    | Pick<
        QueryKey<Options<ListEventsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListEventsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listEventsInfiniteQueryKey(options),
    }
  );
};

export const listDomainsQueryKey = (options?: Options<ListDomainsData>) =>
  createQueryKey("listDomains", options);

export const listDomainsOptions = (options?: Options<ListDomainsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listDomains({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listDomainsQueryKey(options),
  });
};

export const listDomainsInfiniteQueryKey = (
  options?: Options<ListDomainsData>
): QueryKey<Options<ListDomainsData>> =>
  createQueryKey("listDomains", options, true);

export const listDomainsInfiniteOptions = (
  options?: Options<ListDomainsData>
) => {
  return infiniteQueryOptions<
    ListDomainsResponse,
    ListDomainsError,
    InfiniteData<ListDomainsResponse>,
    QueryKey<Options<ListDomainsData>>,
    | number
    | Pick<
        QueryKey<Options<ListDomainsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListDomainsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDomains({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listDomainsInfiniteQueryKey(options),
    }
  );
};

export const createDomainQueryKey = (options: Options<CreateDomainData>) =>
  createQueryKey("createDomain", options);

export const createDomainOptions = (options: Options<CreateDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDomainQueryKey(options),
  });
};

export const createDomainMutation = (
  options?: Partial<Options<CreateDomainData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateDomainResponse,
    CreateDomainError,
    Options<CreateDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteDomainMutation = (
  options?: Partial<Options<DeleteDomainData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteDomainResponse,
    DeleteDomainError,
    Options<DeleteDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDomainQueryKey = (options: Options<GetDomainData>) =>
  createQueryKey("getDomain", options);

export const getDomainOptions = (options: Options<GetDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDomainQueryKey(options),
  });
};

export const getDomainRrsetsQueryKey = (
  options: Options<GetDomainRrsetsData>
) => createQueryKey("getDomainRrsets", options);

export const getDomainRrsetsOptions = (
  options: Options<GetDomainRrsetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDomainRrsets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDomainRrsetsQueryKey(options),
  });
};

export const listFabricsQueryKey = (options?: Options<ListFabricsData>) =>
  createQueryKey("listFabrics", options);

export const listFabricsOptions = (options?: Options<ListFabricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricsQueryKey(options),
  });
};

export const listFabricsInfiniteQueryKey = (
  options?: Options<ListFabricsData>
): QueryKey<Options<ListFabricsData>> =>
  createQueryKey("listFabrics", options, true);

export const listFabricsInfiniteOptions = (
  options?: Options<ListFabricsData>
) => {
  return infiniteQueryOptions<
    ListFabricsResponse,
    ListFabricsError,
    InfiniteData<ListFabricsResponse>,
    QueryKey<Options<ListFabricsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricsInfiniteQueryKey(options),
    }
  );
};

export const createFabricQueryKey = (options: Options<CreateFabricData>) =>
  createQueryKey("createFabric", options);

export const createFabricOptions = (options: Options<CreateFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricQueryKey(options),
  });
};

export const createFabricMutation = (
  options?: Partial<Options<CreateFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricResponse,
    CreateFabricError,
    Options<CreateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricMutation = (
  options?: Partial<Options<DeleteFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricResponse,
    DeleteFabricError,
    Options<DeleteFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricQueryKey = (options: Options<GetFabricData>) =>
  createQueryKey("getFabric", options);

export const getFabricOptions = (options: Options<GetFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricQueryKey(options),
  });
};

export const updateFabricMutation = (
  options?: Partial<Options<UpdateFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricResponse,
    UpdateFabricError,
    Options<UpdateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listInterfacesQueryKey = (options: Options<ListInterfacesData>) =>
  createQueryKey("listInterfaces", options);

export const listInterfacesOptions = (options: Options<ListInterfacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listInterfaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listInterfacesQueryKey(options),
  });
};

export const listInterfacesInfiniteQueryKey = (
  options: Options<ListInterfacesData>
): QueryKey<Options<ListInterfacesData>> =>
  createQueryKey("listInterfaces", options, true);

export const listInterfacesInfiniteOptions = (
  options: Options<ListInterfacesData>
) => {
  return infiniteQueryOptions<
    ListInterfacesResponse,
    ListInterfacesError,
    InfiniteData<ListInterfacesResponse>,
    QueryKey<Options<ListInterfacesData>>,
    | number
    | Pick<
        QueryKey<Options<ListInterfacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListInterfacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listInterfaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listInterfacesInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetIprangeQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => createQueryKey("listFabricVlanSubnetIprange", options);

export const listFabricVlanSubnetIprangeOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const listFabricVlanSubnetIprangeInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
): QueryKey<Options<ListFabricVlanSubnetIprangeData>> =>
  createQueryKey("listFabricVlanSubnetIprange", options, true);

export const listFabricVlanSubnetIprangeInfiniteOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetIprangeResponse,
    ListFabricVlanSubnetIprangeError,
    InfiniteData<ListFabricVlanSubnetIprangeResponse>,
    QueryKey<Options<ListFabricVlanSubnetIprangeData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetIprange({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetIprangeInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetIprangeQueryKey = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => createQueryKey("createFabricVlanSubnetIprange", options);

export const createFabricVlanSubnetIprangeOptions = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const createFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetIprangeResponse,
    CreateFabricVlanSubnetIprangeError,
    Options<CreateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetIprangeResponse,
    DeleteFabricVlanSubnetIprangeError,
    Options<DeleteFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetIprangeResponse,
    UpdateFabricVlanSubnetIprangeError,
    Options<UpdateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetIprangeQueryKey = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => createQueryKey("getFabricVlanSubnetIprange", options);

export const getFabricVlanSubnetIprangeOptions = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const getMachinePowerParametersQueryKey = (
  options: Options<GetMachinePowerParametersData>
) => createQueryKey("getMachinePowerParameters", options);

export const getMachinePowerParametersOptions = (
  options: Options<GetMachinePowerParametersData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMachinePowerParameters({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMachinePowerParametersQueryKey(options),
  });
};

export const listMachinePciDevicesQueryKey = (
  options: Options<ListMachinePciDevicesData>
) => createQueryKey("listMachinePciDevices", options);

export const listMachinePciDevicesOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachinePciDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinePciDevicesQueryKey(options),
  });
};

export const listMachinePciDevicesInfiniteQueryKey = (
  options: Options<ListMachinePciDevicesData>
): QueryKey<Options<ListMachinePciDevicesData>> =>
  createQueryKey("listMachinePciDevices", options, true);

export const listMachinePciDevicesInfiniteOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachinePciDevicesResponse,
    ListMachinePciDevicesError,
    InfiniteData<ListMachinePciDevicesResponse>,
    QueryKey<Options<ListMachinePciDevicesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachinePciDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinePciDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachinePciDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinePciDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachineUsbDevicesQueryKey = (
  options: Options<ListMachineUsbDevicesData>
) => createQueryKey("listMachineUsbDevices", options);

export const listMachineUsbDevicesOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachineUsbDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachineUsbDevicesQueryKey(options),
  });
};

export const listMachineUsbDevicesInfiniteQueryKey = (
  options: Options<ListMachineUsbDevicesData>
): QueryKey<Options<ListMachineUsbDevicesData>> =>
  createQueryKey("listMachineUsbDevices", options, true);

export const listMachineUsbDevicesInfiniteOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachineUsbDevicesResponse,
    ListMachineUsbDevicesError,
    InfiniteData<ListMachineUsbDevicesResponse>,
    QueryKey<Options<ListMachineUsbDevicesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachineUsbDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachineUsbDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachineUsbDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachineUsbDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachinesQueryKey = (options?: Options<ListMachinesData>) =>
  createQueryKey("listMachines", options);

export const listMachinesOptions = (options?: Options<ListMachinesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinesQueryKey(options),
  });
};

export const listMachinesInfiniteQueryKey = (
  options?: Options<ListMachinesData>
): QueryKey<Options<ListMachinesData>> =>
  createQueryKey("listMachines", options, true);

export const listMachinesInfiniteOptions = (
  options?: Options<ListMachinesData>
) => {
  return infiniteQueryOptions<
    ListMachinesResponse,
    ListMachinesError,
    InfiniteData<ListMachinesResponse>,
    QueryKey<Options<ListMachinesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachinesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachines({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinesInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetReservedIpsQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => createQueryKey("listFabricVlanSubnetReservedIps", options);

export const listFabricVlanSubnetReservedIpsOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetReservedIps({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetReservedIpsQueryKey(options),
  });
};

export const listFabricVlanSubnetReservedIpsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
): QueryKey<Options<ListFabricVlanSubnetReservedIpsData>> =>
  createQueryKey("listFabricVlanSubnetReservedIps", options, true);

export const listFabricVlanSubnetReservedIpsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetReservedIpsResponse,
    ListFabricVlanSubnetReservedIpsError,
    InfiniteData<ListFabricVlanSubnetReservedIpsResponse>,
    QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetReservedIps({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetReservedIpsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetReservedIpQueryKey = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => createQueryKey("createFabricVlanSubnetReservedIp", options);

export const createFabricVlanSubnetReservedIpOptions = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetReservedIpQueryKey(options),
  });
};

export const createFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetReservedIpResponse,
    CreateFabricVlanSubnetReservedIpError,
    Options<CreateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetReservedIpResponse,
    DeleteFabricVlanSubnetReservedIpError,
    Options<DeleteFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetReservedIpResponse,
    UpdateFabricVlanSubnetReservedIpError,
    Options<UpdateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetReservedIpQueryKey = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => createQueryKey("getFabricVlanSubnetReservedIp", options);

export const getFabricVlanSubnetReservedIpOptions = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetReservedIpQueryKey(options),
  });
};

export const listResourcePoolsQueryKey = (
  options?: Options<ListResourcePoolsData>
) => createQueryKey("listResourcePools", options);

export const listResourcePoolsOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listResourcePools({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listResourcePoolsQueryKey(options),
  });
};

export const listResourcePoolsInfiniteQueryKey = (
  options?: Options<ListResourcePoolsData>
): QueryKey<Options<ListResourcePoolsData>> =>
  createQueryKey("listResourcePools", options, true);

export const listResourcePoolsInfiniteOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return infiniteQueryOptions<
    ListResourcePoolsResponse,
    ListResourcePoolsError,
    InfiniteData<ListResourcePoolsResponse>,
    QueryKey<Options<ListResourcePoolsData>>,
    | number
    | Pick<
        QueryKey<Options<ListResourcePoolsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListResourcePoolsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listResourcePools({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listResourcePoolsInfiniteQueryKey(options),
    }
  );
};

export const createResourcePoolQueryKey = (
  options: Options<CreateResourcePoolData>
) => createQueryKey("createResourcePool", options);

export const createResourcePoolOptions = (
  options: Options<CreateResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createResourcePoolQueryKey(options),
  });
};

export const createResourcePoolMutation = (
  options?: Partial<Options<CreateResourcePoolData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateResourcePoolResponse,
    CreateResourcePoolError,
    Options<CreateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteResourcePoolMutation = (
  options?: Partial<Options<DeleteResourcePoolData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteResourcePoolResponse,
    DeleteResourcePoolError,
    Options<DeleteResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getResourcePoolQueryKey = (
  options: Options<GetResourcePoolData>
) => createQueryKey("getResourcePool", options);

export const getResourcePoolOptions = (
  options: Options<GetResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getResourcePoolQueryKey(options),
  });
};

export const updateResourcePoolMutation = (
  options?: Partial<Options<UpdateResourcePoolData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateResourcePoolResponse,
    UpdateResourcePoolError,
    Options<UpdateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listResourcePoolsWithSummaryQueryKey = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => createQueryKey("listResourcePoolsWithSummary", options);

export const listResourcePoolsWithSummaryOptions = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listResourcePoolsWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listResourcePoolsWithSummaryQueryKey(options),
  });
};

export const listResourcePoolsWithSummaryInfiniteQueryKey = (
  options?: Options<ListResourcePoolsWithSummaryData>
): QueryKey<Options<ListResourcePoolsWithSummaryData>> =>
  createQueryKey("listResourcePoolsWithSummary", options, true);

export const listResourcePoolsWithSummaryInfiniteOptions = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListResourcePoolsWithSummaryResponse,
    ListResourcePoolsWithSummaryError,
    InfiniteData<ListResourcePoolsWithSummaryResponse>,
    QueryKey<Options<ListResourcePoolsWithSummaryData>>,
    | number
    | Pick<
        QueryKey<Options<ListResourcePoolsWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListResourcePoolsWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listResourcePoolsWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listResourcePoolsWithSummaryInfiniteQueryKey(options),
    }
  );
};

export const listSpacesQueryKey = (options?: Options<ListSpacesData>) =>
  createQueryKey("listSpaces", options);

export const listSpacesOptions = (options?: Options<ListSpacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listSpaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listSpacesQueryKey(options),
  });
};

export const listSpacesInfiniteQueryKey = (
  options?: Options<ListSpacesData>
): QueryKey<Options<ListSpacesData>> =>
  createQueryKey("listSpaces", options, true);

export const listSpacesInfiniteOptions = (
  options?: Options<ListSpacesData>
) => {
  return infiniteQueryOptions<
    ListSpacesResponse,
    ListSpacesError,
    InfiniteData<ListSpacesResponse>,
    QueryKey<Options<ListSpacesData>>,
    | number
    | Pick<
        QueryKey<Options<ListSpacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListSpacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listSpaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listSpacesInfiniteQueryKey(options),
    }
  );
};

export const createSpaceQueryKey = (options: Options<CreateSpaceData>) =>
  createQueryKey("createSpace", options);

export const createSpaceOptions = (options: Options<CreateSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createSpaceQueryKey(options),
  });
};

export const createSpaceMutation = (
  options?: Partial<Options<CreateSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateSpaceResponse,
    CreateSpaceError,
    Options<CreateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteSpaceMutation = (
  options?: Partial<Options<DeleteSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteSpaceResponse,
    DeleteSpaceError,
    Options<DeleteSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSpaceQueryKey = (options: Options<GetSpaceData>) =>
  createQueryKey("getSpace", options);

export const getSpaceOptions = (options: Options<GetSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSpaceQueryKey(options),
  });
};

export const updateSpaceMutation = (
  options?: Partial<Options<UpdateSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateSpaceResponse,
    UpdateSpaceError,
    Options<UpdateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listUserSshkeysQueryKey = (
  options?: Options<ListUserSshkeysData>
) => createQueryKey("listUserSshkeys", options);

export const listUserSshkeysOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUserSshkeysQueryKey(options),
  });
};

export const listUserSshkeysInfiniteQueryKey = (
  options?: Options<ListUserSshkeysData>
): QueryKey<Options<ListUserSshkeysData>> =>
  createQueryKey("listUserSshkeys", options, true);

export const listUserSshkeysInfiniteOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return infiniteQueryOptions<
    ListUserSshkeysResponse,
    ListUserSshkeysError,
    InfiniteData<ListUserSshkeysResponse>,
    QueryKey<Options<ListUserSshkeysData>>,
    | number
    | Pick<
        QueryKey<Options<ListUserSshkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUserSshkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUserSshkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUserSshkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSshkeysQueryKey = (
  options: Options<CreateUserSshkeysData>
) => createQueryKey("createUserSshkeys", options);

export const createUserSshkeysOptions = (
  options: Options<CreateUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSshkeysQueryKey(options),
  });
};

export const createUserSshkeysMutation = (
  options?: Partial<Options<CreateUserSshkeysData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserSshkeysResponse,
    CreateUserSshkeysError,
    Options<CreateUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserSshkeyMutation = (
  options?: Partial<Options<DeleteUserSshkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSshkeyResponse,
    DeleteUserSshkeyError,
    Options<DeleteUserSshkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSshkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSshkeyQueryKey = (options: Options<GetUserSshkeyData>) =>
  createQueryKey("getUserSshkey", options);

export const getUserSshkeyOptions = (options: Options<GetUserSshkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSshkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSshkeyQueryKey(options),
  });
};

export const importUserSshkeysQueryKey = (
  options: Options<ImportUserSshkeysData>
) => createQueryKey("importUserSshkeys", options);

export const importUserSshkeysOptions = (
  options: Options<ImportUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: importUserSshkeysQueryKey(options),
  });
};

export const importUserSshkeysMutation = (
  options?: Partial<Options<ImportUserSshkeysData>>
) => {
  const mutationOptions: UseMutationOptions<
    ImportUserSshkeysResponse,
    ImportUserSshkeysError,
    Options<ImportUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeysQueryKey = (options?: Options<GetUserSslkeysData>) =>
  createQueryKey("getUserSslkeys", options);

export const getUserSslkeysOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeysQueryKey(options),
  });
};

export const getUserSslkeysInfiniteQueryKey = (
  options?: Options<GetUserSslkeysData>
): QueryKey<Options<GetUserSslkeysData>> =>
  createQueryKey("getUserSslkeys", options, true);

export const getUserSslkeysInfiniteOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return infiniteQueryOptions<
    GetUserSslkeysResponse,
    GetUserSslkeysError,
    InfiniteData<GetUserSslkeysResponse>,
    QueryKey<Options<GetUserSslkeysData>>,
    | number
    | Pick<
        QueryKey<Options<GetUserSslkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserSslkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserSslkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserSslkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSslkeyQueryKey = (
  options: Options<CreateUserSslkeyData>
) => createQueryKey("createUserSslkey", options);

export const createUserSslkeyOptions = (
  options: Options<CreateUserSslkeyData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSslkeyQueryKey(options),
  });
};

export const createUserSslkeyMutation = (
  options?: Partial<Options<CreateUserSslkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserSslkeyResponse,
    CreateUserSslkeyError,
    Options<CreateUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserSslkeyMutation = (
  options?: Partial<Options<DeleteUserSslkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSslkeyResponse,
    DeleteUserSslkeyError,
    Options<DeleteUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeyQueryKey = (options: Options<GetUserSslkeyData>) =>
  createQueryKey("getUserSslkey", options);

export const getUserSslkeyOptions = (options: Options<GetUserSslkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeyQueryKey(options),
  });
};

export const listFabricVlanSubnetsQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
) => createQueryKey("listFabricVlanSubnets", options);

export const listFabricVlanSubnetsOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetsQueryKey(options),
  });
};

export const listFabricVlanSubnetsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
): QueryKey<Options<ListFabricVlanSubnetsData>> =>
  createQueryKey("listFabricVlanSubnets", options, true);

export const listFabricVlanSubnetsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetsResponse,
    ListFabricVlanSubnetsError,
    InfiniteData<ListFabricVlanSubnetsResponse>,
    QueryKey<Options<ListFabricVlanSubnetsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnets({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetQueryKey = (
  options: Options<CreateFabricVlanSubnetData>
) => createQueryKey("createFabricVlanSubnet", options);

export const createFabricVlanSubnetOptions = (
  options: Options<CreateFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetQueryKey(options),
  });
};

export const createFabricVlanSubnetMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetResponse,
    CreateFabricVlanSubnetError,
    Options<CreateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetResponse,
    DeleteFabricVlanSubnetError,
    Options<DeleteFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetResponse,
    UpdateFabricVlanSubnetError,
    Options<UpdateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetQueryKey = (
  options: Options<GetFabricVlanSubnetData>
) => createQueryKey("getFabricVlanSubnet", options);

export const getFabricVlanSubnetOptions = (
  options: Options<GetFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetQueryKey(options),
  });
};

export const getUserInfoQueryKey = (options?: Options<GetUserInfoData>) =>
  createQueryKey("getUserInfo", options);

export const getUserInfoOptions = (options?: Options<GetUserInfoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserInfoQueryKey(options),
  });
};

export const listUsersQueryKey = (options?: Options<ListUsersData>) =>
  createQueryKey("listUsers", options);

export const listUsersOptions = (options?: Options<ListUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUsersQueryKey(options),
  });
};

export const listUsersInfiniteQueryKey = (
  options?: Options<ListUsersData>
): QueryKey<Options<ListUsersData>> =>
  createQueryKey("listUsers", options, true);

export const listUsersInfiniteOptions = (options?: Options<ListUsersData>) => {
  return infiniteQueryOptions<
    ListUsersResponse,
    ListUsersError,
    InfiniteData<ListUsersResponse>,
    QueryKey<Options<ListUsersData>>,
    | number
    | Pick<
        QueryKey<Options<ListUsersData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUsersData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUsersInfiniteQueryKey(options),
    }
  );
};

export const createUserQueryKey = (options: Options<CreateUserData>) =>
  createQueryKey("createUser", options);

export const createUserOptions = (options: Options<CreateUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserQueryKey(options),
  });
};

export const createUserMutation = (
  options?: Partial<Options<CreateUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserResponse,
    CreateUserError,
    Options<CreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserQueryKey = (options: Options<GetUserData>) =>
  createQueryKey("getUser", options);

export const getUserOptions = (options: Options<GetUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserQueryKey(options),
  });
};

export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listFabricVlansQueryKey = (
  options: Options<ListFabricVlansData>
) => createQueryKey("listFabricVlans", options);

export const listFabricVlansOptions = (
  options: Options<ListFabricVlansData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlans({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlansQueryKey(options),
  });
};

export const listFabricVlansInfiniteQueryKey = (
  options: Options<ListFabricVlansData>
): QueryKey<Options<ListFabricVlansData>> =>
  createQueryKey("listFabricVlans", options, true);

export const listFabricVlansInfiniteOptions = (
  options: Options<ListFabricVlansData>
) => {
  return infiniteQueryOptions<
    ListFabricVlansResponse,
    ListFabricVlansError,
    InfiniteData<ListFabricVlansResponse>,
    QueryKey<Options<ListFabricVlansData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlansData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlansData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlans({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlansInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanQueryKey = (
  options: Options<CreateFabricVlanData>
) => createQueryKey("createFabricVlan", options);

export const createFabricVlanOptions = (
  options: Options<CreateFabricVlanData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanQueryKey(options),
  });
};

export const createFabricVlanMutation = (
  options?: Partial<Options<CreateFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanResponse,
    CreateFabricVlanError,
    Options<CreateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanMutation = (
  options?: Partial<Options<DeleteFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanResponse,
    DeleteFabricVlanError,
    Options<DeleteFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanQueryKey = (options: Options<GetFabricVlanData>) =>
  createQueryKey("getFabricVlan", options);

export const getFabricVlanOptions = (options: Options<GetFabricVlanData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanQueryKey(options),
  });
};

export const updateFabricVlanMutation = (
  options?: Partial<Options<UpdateFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanResponse,
    UpdateFabricVlanError,
    Options<UpdateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesQueryKey = (options?: Options<ListZonesData>) =>
  createQueryKey("listZones", options);

export const listZonesOptions = (options?: Options<ListZonesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZones({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesQueryKey(options),
  });
};

export const listZonesInfiniteQueryKey = (
  options?: Options<ListZonesData>
): QueryKey<Options<ListZonesData>> =>
  createQueryKey("listZones", options, true);

export const listZonesInfiniteOptions = (options?: Options<ListZonesData>) => {
  return infiniteQueryOptions<
    ListZonesResponse,
    ListZonesError,
    InfiniteData<ListZonesResponse>,
    QueryKey<Options<ListZonesData>>,
    | number
    | Pick<
        QueryKey<Options<ListZonesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZones({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesInfiniteQueryKey(options),
    }
  );
};

export const createZoneQueryKey = (options: Options<CreateZoneData>) =>
  createQueryKey("createZone", options);

export const createZoneOptions = (options: Options<CreateZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createZoneQueryKey(options),
  });
};

export const createZoneMutation = (
  options?: Partial<Options<CreateZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateZoneResponse,
    CreateZoneError,
    Options<CreateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteZoneMutation = (
  options?: Partial<Options<DeleteZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteZoneResponse,
    DeleteZoneError,
    Options<DeleteZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getZoneQueryKey = (options: Options<GetZoneData>) =>
  createQueryKey("getZone", options);

export const getZoneOptions = (options: Options<GetZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getZoneQueryKey(options),
  });
};

export const updateZoneMutation = (
  options?: Partial<Options<UpdateZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateZoneResponse,
    UpdateZoneError,
    Options<UpdateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesWithSummaryQueryKey = (
  options?: Options<ListZonesWithSummaryData>
) => createQueryKey("listZonesWithSummary", options);

export const listZonesWithSummaryOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZonesWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesWithSummaryQueryKey(options),
  });
};

export const listZonesWithSummaryInfiniteQueryKey = (
  options?: Options<ListZonesWithSummaryData>
): QueryKey<Options<ListZonesWithSummaryData>> =>
  createQueryKey("listZonesWithSummary", options, true);

export const listZonesWithSummaryInfiniteOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListZonesWithSummaryResponse,
    ListZonesWithSummaryError,
    InfiniteData<ListZonesWithSummaryResponse>,
    QueryKey<Options<ListZonesWithSummaryData>>,
    | number
    | Pick<
        QueryKey<Options<ListZonesWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZonesWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesWithSummaryInfiniteQueryKey(options),
    }
  );
};
