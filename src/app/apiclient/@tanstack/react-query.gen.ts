// This file is auto-generated by @hey-api/openapi-ts

import type { Options } from "@hey-api/client-fetch";
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query";

import {
  accessToken,
  login,
  listEvents,
  listDomains,
  createDomain,
  deleteDomain,
  getDomain,
  listFabrics,
  createFabric,
  deleteFabric,
  getFabric,
  updateFabric,
  listInterfaces,
  listFabricVlanSubnetIprange,
  createFabricVlanSubnetIprange,
  deleteFabricVlanSubnetIprange,
  updateFabricVlanSubnetIprange,
  getFabricVlanSubnetIprange,
  getMachinePowerParameters,
  listMachinePciDevices,
  listMachineUsbDevices,
  listMachines,
  listFabricVlanSubnetReservedIps,
  createFabricVlanSubnetReservedIp,
  deleteFabricVlanSubnetReservedIp,
  updateFabricVlanSubnetReservedIp,
  getFabricVlanSubnetReservedIp,
  listResourcePools,
  createResourcePool,
  getResourcePool,
  updateResourcePool,
  listSpaces,
  createSpace,
  deleteSpace,
  getSpace,
  updateSpace,
  listUserSshkeys,
  createUserSshkeys,
  deleteUserSshkey,
  getUserSshkey,
  importUserSshkeys,
  getUserSslkeys,
  createUserSslkey,
  deleteUserSslkey,
  getUserSslkey,
  listFabricVlanSubnets,
  createFabricVlanSubnet,
  deleteFabricVlanSubnet,
  updateFabricVlanSubnet,
  getFabricVlanSubnet,
  getUserInfo,
  listUsers,
  createUser,
  deleteUser,
  getUser,
  updateUser,
  listFabricVlans,
  createFabricVlan,
  deleteFabricVlan,
  getFabricVlan,
  updateFabricVlan,
  listZones,
  createZone,
  deleteZone,
  getZone,
  updateZone,
  listZonesWithSummary,
  client,
} from "../sdk.gen";
import type {
  AccessTokenData,
  LoginData,
  LoginError,
  LoginResponse,
  ListEventsData,
  ListEventsError,
  ListEventsResponse,
  ListDomainsData,
  ListDomainsError,
  ListDomainsResponse,
  CreateDomainData,
  CreateDomainError,
  CreateDomainResponse,
  DeleteDomainData,
  DeleteDomainError,
  DeleteDomainResponse,
  GetDomainData,
  ListFabricsData,
  ListFabricsError,
  ListFabricsResponse,
  CreateFabricData,
  CreateFabricError,
  CreateFabricResponse,
  DeleteFabricData,
  DeleteFabricError,
  DeleteFabricResponse,
  GetFabricData,
  UpdateFabricData,
  UpdateFabricError,
  UpdateFabricResponse,
  ListInterfacesData,
  ListInterfacesError,
  ListInterfacesResponse,
  ListFabricVlanSubnetIprangeData,
  ListFabricVlanSubnetIprangeError,
  ListFabricVlanSubnetIprangeResponse,
  CreateFabricVlanSubnetIprangeData,
  CreateFabricVlanSubnetIprangeError,
  CreateFabricVlanSubnetIprangeResponse,
  DeleteFabricVlanSubnetIprangeData,
  DeleteFabricVlanSubnetIprangeError,
  DeleteFabricVlanSubnetIprangeResponse,
  UpdateFabricVlanSubnetIprangeData,
  UpdateFabricVlanSubnetIprangeError,
  UpdateFabricVlanSubnetIprangeResponse,
  GetFabricVlanSubnetIprangeData,
  GetMachinePowerParametersData,
  ListMachinePciDevicesData,
  ListMachinePciDevicesError,
  ListMachinePciDevicesResponse,
  ListMachineUsbDevicesData,
  ListMachineUsbDevicesError,
  ListMachineUsbDevicesResponse,
  ListMachinesData,
  ListMachinesError,
  ListMachinesResponse,
  ListFabricVlanSubnetReservedIpsData,
  ListFabricVlanSubnetReservedIpsError,
  ListFabricVlanSubnetReservedIpsResponse,
  CreateFabricVlanSubnetReservedIpData,
  CreateFabricVlanSubnetReservedIpError,
  CreateFabricVlanSubnetReservedIpResponse,
  DeleteFabricVlanSubnetReservedIpData,
  DeleteFabricVlanSubnetReservedIpError,
  DeleteFabricVlanSubnetReservedIpResponse,
  UpdateFabricVlanSubnetReservedIpData,
  UpdateFabricVlanSubnetReservedIpError,
  UpdateFabricVlanSubnetReservedIpResponse,
  GetFabricVlanSubnetReservedIpData,
  ListResourcePoolsData,
  ListResourcePoolsError,
  ListResourcePoolsResponse,
  CreateResourcePoolData,
  CreateResourcePoolError,
  CreateResourcePoolResponse,
  GetResourcePoolData,
  UpdateResourcePoolData,
  UpdateResourcePoolError,
  UpdateResourcePoolResponse,
  ListSpacesData,
  ListSpacesError,
  ListSpacesResponse,
  CreateSpaceData,
  CreateSpaceError,
  CreateSpaceResponse,
  DeleteSpaceData,
  DeleteSpaceError,
  DeleteSpaceResponse,
  GetSpaceData,
  UpdateSpaceData,
  UpdateSpaceError,
  UpdateSpaceResponse,
  ListUserSshkeysData,
  ListUserSshkeysError,
  ListUserSshkeysResponse,
  CreateUserSshkeysData,
  CreateUserSshkeysError,
  CreateUserSshkeysResponse,
  DeleteUserSshkeyData,
  DeleteUserSshkeyError,
  DeleteUserSshkeyResponse,
  GetUserSshkeyData,
  ImportUserSshkeysData,
  ImportUserSshkeysError,
  ImportUserSshkeysResponse,
  GetUserSslkeysData,
  GetUserSslkeysError,
  GetUserSslkeysResponse,
  CreateUserSslkeyData,
  CreateUserSslkeyError,
  CreateUserSslkeyResponse,
  DeleteUserSslkeyData,
  DeleteUserSslkeyError,
  DeleteUserSslkeyResponse,
  GetUserSslkeyData,
  ListFabricVlanSubnetsData,
  ListFabricVlanSubnetsError,
  ListFabricVlanSubnetsResponse,
  CreateFabricVlanSubnetData,
  CreateFabricVlanSubnetError,
  CreateFabricVlanSubnetResponse,
  DeleteFabricVlanSubnetData,
  DeleteFabricVlanSubnetError,
  DeleteFabricVlanSubnetResponse,
  UpdateFabricVlanSubnetData,
  UpdateFabricVlanSubnetError,
  UpdateFabricVlanSubnetResponse,
  GetFabricVlanSubnetData,
  GetUserInfoData,
  ListUsersData,
  ListUsersError,
  ListUsersResponse,
  CreateUserData,
  CreateUserError,
  CreateUserResponse,
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  ListFabricVlansData,
  ListFabricVlansError,
  ListFabricVlansResponse,
  CreateFabricVlanData,
  CreateFabricVlanError,
  CreateFabricVlanResponse,
  DeleteFabricVlanData,
  DeleteFabricVlanError,
  DeleteFabricVlanResponse,
  GetFabricVlanData,
  UpdateFabricVlanData,
  UpdateFabricVlanError,
  UpdateFabricVlanResponse,
  ListZonesData,
  ListZonesError,
  ListZonesResponse,
  CreateZoneData,
  CreateZoneError,
  CreateZoneResponse,
  DeleteZoneData,
  DeleteZoneError,
  DeleteZoneResponse,
  GetZoneData,
  UpdateZoneData,
  UpdateZoneError,
  UpdateZoneResponse,
  ListZonesWithSummaryData,
  ListZonesWithSummaryError,
  ListZonesWithSummaryResponse,
} from "../types.gen";

type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): QueryKey<TOptions>[0] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return params;
};

export const accessTokenQueryKey = (options?: Options<AccessTokenData>) => [
  createQueryKey("accessToken", options),
];

export const accessTokenOptions = (options?: Options<AccessTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await accessToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: accessTokenQueryKey(options),
  });
};

export const loginQueryKey = (options: Options<LoginData>) => [
  createQueryKey("login", options),
];

export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginQueryKey(options),
  });
};

export const loginMutation = (options?: Partial<Options<LoginData>>) => {
  const mutationOptions: UseMutationOptions<
    LoginResponse,
    LoginError,
    Options<LoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await login({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventsQueryKey = (options?: Options<ListEventsData>) => [
  createQueryKey("listEvents", options),
];

export const listEventsOptions = (options?: Options<ListEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventsQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = queryKey[0];
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listEventsInfiniteQueryKey = (
  options?: Options<ListEventsData>
): QueryKey<Options<ListEventsData>> => [
  createQueryKey("listEvents", options, true),
];

export const listEventsInfiniteOptions = (
  options?: Options<ListEventsData>
) => {
  return infiniteQueryOptions<
    ListEventsResponse,
    ListEventsError,
    InfiniteData<ListEventsResponse>,
    QueryKey<Options<ListEventsData>>,
    | number
    | Pick<
        QueryKey<Options<ListEventsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListEventsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listEventsInfiniteQueryKey(options),
    }
  );
};

export const listDomainsQueryKey = (options?: Options<ListDomainsData>) => [
  createQueryKey("listDomains", options),
];

export const listDomainsOptions = (options?: Options<ListDomainsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listDomains({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listDomainsQueryKey(options),
  });
};

export const listDomainsInfiniteQueryKey = (
  options?: Options<ListDomainsData>
): QueryKey<Options<ListDomainsData>> => [
  createQueryKey("listDomains", options, true),
];

export const listDomainsInfiniteOptions = (
  options?: Options<ListDomainsData>
) => {
  return infiniteQueryOptions<
    ListDomainsResponse,
    ListDomainsError,
    InfiniteData<ListDomainsResponse>,
    QueryKey<Options<ListDomainsData>>,
    | number
    | Pick<
        QueryKey<Options<ListDomainsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListDomainsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDomains({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listDomainsInfiniteQueryKey(options),
    }
  );
};

export const createDomainQueryKey = (options: Options<CreateDomainData>) => [
  createQueryKey("createDomain", options),
];

export const createDomainOptions = (options: Options<CreateDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDomainQueryKey(options),
  });
};

export const createDomainMutation = (
  options?: Partial<Options<CreateDomainData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateDomainResponse,
    CreateDomainError,
    Options<CreateDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteDomainMutation = (
  options?: Partial<Options<DeleteDomainData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteDomainResponse,
    DeleteDomainError,
    Options<DeleteDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDomainQueryKey = (options: Options<GetDomainData>) => [
  createQueryKey("getDomain", options),
];

export const getDomainOptions = (options: Options<GetDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDomainQueryKey(options),
  });
};

export const listFabricsQueryKey = (options?: Options<ListFabricsData>) => [
  createQueryKey("listFabrics", options),
];

export const listFabricsOptions = (options?: Options<ListFabricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricsQueryKey(options),
  });
};

export const listFabricsInfiniteQueryKey = (
  options?: Options<ListFabricsData>
): QueryKey<Options<ListFabricsData>> => [
  createQueryKey("listFabrics", options, true),
];

export const listFabricsInfiniteOptions = (
  options?: Options<ListFabricsData>
) => {
  return infiniteQueryOptions<
    ListFabricsResponse,
    ListFabricsError,
    InfiniteData<ListFabricsResponse>,
    QueryKey<Options<ListFabricsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricsInfiniteQueryKey(options),
    }
  );
};

export const createFabricQueryKey = (options: Options<CreateFabricData>) => [
  createQueryKey("createFabric", options),
];

export const createFabricOptions = (options: Options<CreateFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricQueryKey(options),
  });
};

export const createFabricMutation = (
  options?: Partial<Options<CreateFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricResponse,
    CreateFabricError,
    Options<CreateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricMutation = (
  options?: Partial<Options<DeleteFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricResponse,
    DeleteFabricError,
    Options<DeleteFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricQueryKey = (options: Options<GetFabricData>) => [
  createQueryKey("getFabric", options),
];

export const getFabricOptions = (options: Options<GetFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricQueryKey(options),
  });
};

export const updateFabricMutation = (
  options?: Partial<Options<UpdateFabricData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricResponse,
    UpdateFabricError,
    Options<UpdateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listInterfacesQueryKey = (
  options: Options<ListInterfacesData>
) => [createQueryKey("listInterfaces", options)];

export const listInterfacesOptions = (options: Options<ListInterfacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listInterfaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listInterfacesQueryKey(options),
  });
};

export const listInterfacesInfiniteQueryKey = (
  options: Options<ListInterfacesData>
): QueryKey<Options<ListInterfacesData>> => [
  createQueryKey("listInterfaces", options, true),
];

export const listInterfacesInfiniteOptions = (
  options: Options<ListInterfacesData>
) => {
  return infiniteQueryOptions<
    ListInterfacesResponse,
    ListInterfacesError,
    InfiniteData<ListInterfacesResponse>,
    QueryKey<Options<ListInterfacesData>>,
    | number
    | Pick<
        QueryKey<Options<ListInterfacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListInterfacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listInterfaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listInterfacesInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetIprangeQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => [createQueryKey("listFabricVlanSubnetIprange", options)];

export const listFabricVlanSubnetIprangeOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const listFabricVlanSubnetIprangeInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
): QueryKey<Options<ListFabricVlanSubnetIprangeData>> => [
  createQueryKey("listFabricVlanSubnetIprange", options, true),
];

export const listFabricVlanSubnetIprangeInfiniteOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetIprangeResponse,
    ListFabricVlanSubnetIprangeError,
    InfiniteData<ListFabricVlanSubnetIprangeResponse>,
    QueryKey<Options<ListFabricVlanSubnetIprangeData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetIprange({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetIprangeInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetIprangeQueryKey = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => [createQueryKey("createFabricVlanSubnetIprange", options)];

export const createFabricVlanSubnetIprangeOptions = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const createFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetIprangeResponse,
    CreateFabricVlanSubnetIprangeError,
    Options<CreateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetIprangeResponse,
    DeleteFabricVlanSubnetIprangeError,
    Options<DeleteFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetIprangeData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetIprangeResponse,
    UpdateFabricVlanSubnetIprangeError,
    Options<UpdateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetIprangeQueryKey = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => [createQueryKey("getFabricVlanSubnetIprange", options)];

export const getFabricVlanSubnetIprangeOptions = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const getMachinePowerParametersQueryKey = (
  options: Options<GetMachinePowerParametersData>
) => [createQueryKey("getMachinePowerParameters", options)];

export const getMachinePowerParametersOptions = (
  options: Options<GetMachinePowerParametersData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMachinePowerParameters({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMachinePowerParametersQueryKey(options),
  });
};

export const listMachinePciDevicesQueryKey = (
  options: Options<ListMachinePciDevicesData>
) => [createQueryKey("listMachinePciDevices", options)];

export const listMachinePciDevicesOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachinePciDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinePciDevicesQueryKey(options),
  });
};

export const listMachinePciDevicesInfiniteQueryKey = (
  options: Options<ListMachinePciDevicesData>
): QueryKey<Options<ListMachinePciDevicesData>> => [
  createQueryKey("listMachinePciDevices", options, true),
];

export const listMachinePciDevicesInfiniteOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachinePciDevicesResponse,
    ListMachinePciDevicesError,
    InfiniteData<ListMachinePciDevicesResponse>,
    QueryKey<Options<ListMachinePciDevicesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachinePciDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinePciDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachinePciDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinePciDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachineUsbDevicesQueryKey = (
  options: Options<ListMachineUsbDevicesData>
) => [createQueryKey("listMachineUsbDevices", options)];

export const listMachineUsbDevicesOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachineUsbDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachineUsbDevicesQueryKey(options),
  });
};

export const listMachineUsbDevicesInfiniteQueryKey = (
  options: Options<ListMachineUsbDevicesData>
): QueryKey<Options<ListMachineUsbDevicesData>> => [
  createQueryKey("listMachineUsbDevices", options, true),
];

export const listMachineUsbDevicesInfiniteOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachineUsbDevicesResponse,
    ListMachineUsbDevicesError,
    InfiniteData<ListMachineUsbDevicesResponse>,
    QueryKey<Options<ListMachineUsbDevicesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachineUsbDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachineUsbDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachineUsbDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachineUsbDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachinesQueryKey = (options?: Options<ListMachinesData>) => [
  createQueryKey("listMachines", options),
];

export const listMachinesOptions = (options?: Options<ListMachinesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinesQueryKey(options),
  });
};

export const listMachinesInfiniteQueryKey = (
  options?: Options<ListMachinesData>
): QueryKey<Options<ListMachinesData>> => [
  createQueryKey("listMachines", options, true),
];

export const listMachinesInfiniteOptions = (
  options?: Options<ListMachinesData>
) => {
  return infiniteQueryOptions<
    ListMachinesResponse,
    ListMachinesError,
    InfiniteData<ListMachinesResponse>,
    QueryKey<Options<ListMachinesData>>,
    | number
    | Pick<
        QueryKey<Options<ListMachinesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachines({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinesInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetReservedIpsQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => [createQueryKey("listFabricVlanSubnetReservedIps", options)];

export const listFabricVlanSubnetReservedIpsOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetReservedIps({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetReservedIpsQueryKey(options),
  });
};

export const listFabricVlanSubnetReservedIpsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
): QueryKey<Options<ListFabricVlanSubnetReservedIpsData>> => [
  createQueryKey("listFabricVlanSubnetReservedIps", options, true),
];

export const listFabricVlanSubnetReservedIpsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetReservedIpsResponse,
    ListFabricVlanSubnetReservedIpsError,
    InfiniteData<ListFabricVlanSubnetReservedIpsResponse>,
    QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetReservedIps({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetReservedIpsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetReservedIpQueryKey = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => [createQueryKey("createFabricVlanSubnetReservedIp", options)];

export const createFabricVlanSubnetReservedIpOptions = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetReservedIpQueryKey(options),
  });
};

export const createFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetReservedIpResponse,
    CreateFabricVlanSubnetReservedIpError,
    Options<CreateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetReservedIpResponse,
    DeleteFabricVlanSubnetReservedIpError,
    Options<DeleteFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetReservedIpData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetReservedIpResponse,
    UpdateFabricVlanSubnetReservedIpError,
    Options<UpdateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetReservedIpQueryKey = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => [createQueryKey("getFabricVlanSubnetReservedIp", options)];

export const getFabricVlanSubnetReservedIpOptions = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetReservedIpQueryKey(options),
  });
};

export const listResourcePoolsQueryKey = (
  options?: Options<ListResourcePoolsData>
) => [createQueryKey("listResourcePools", options)];

export const listResourcePoolsOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listResourcePools({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listResourcePoolsQueryKey(options),
  });
};

export const listResourcePoolsInfiniteQueryKey = (
  options?: Options<ListResourcePoolsData>
): QueryKey<Options<ListResourcePoolsData>> => [
  createQueryKey("listResourcePools", options, true),
];

export const listResourcePoolsInfiniteOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return infiniteQueryOptions<
    ListResourcePoolsResponse,
    ListResourcePoolsError,
    InfiniteData<ListResourcePoolsResponse>,
    QueryKey<Options<ListResourcePoolsData>>,
    | number
    | Pick<
        QueryKey<Options<ListResourcePoolsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListResourcePoolsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listResourcePools({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listResourcePoolsInfiniteQueryKey(options),
    }
  );
};

export const createResourcePoolQueryKey = (
  options: Options<CreateResourcePoolData>
) => [createQueryKey("createResourcePool", options)];

export const createResourcePoolOptions = (
  options: Options<CreateResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createResourcePoolQueryKey(options),
  });
};

export const createResourcePoolMutation = (
  options?: Partial<Options<CreateResourcePoolData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateResourcePoolResponse,
    CreateResourcePoolError,
    Options<CreateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getResourcePoolQueryKey = (
  options: Options<GetResourcePoolData>
) => [createQueryKey("getResourcePool", options)];

export const getResourcePoolOptions = (
  options: Options<GetResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getResourcePoolQueryKey(options),
  });
};

export const updateResourcePoolMutation = (
  options?: Partial<Options<UpdateResourcePoolData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateResourcePoolResponse,
    UpdateResourcePoolError,
    Options<UpdateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listSpacesQueryKey = (options?: Options<ListSpacesData>) => [
  createQueryKey("listSpaces", options),
];

export const listSpacesOptions = (options?: Options<ListSpacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listSpaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listSpacesQueryKey(options),
  });
};

export const listSpacesInfiniteQueryKey = (
  options?: Options<ListSpacesData>
): QueryKey<Options<ListSpacesData>> => [
  createQueryKey("listSpaces", options, true),
];

export const listSpacesInfiniteOptions = (
  options?: Options<ListSpacesData>
) => {
  return infiniteQueryOptions<
    ListSpacesResponse,
    ListSpacesError,
    InfiniteData<ListSpacesResponse>,
    QueryKey<Options<ListSpacesData>>,
    | number
    | Pick<
        QueryKey<Options<ListSpacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListSpacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listSpaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listSpacesInfiniteQueryKey(options),
    }
  );
};

export const createSpaceQueryKey = (options: Options<CreateSpaceData>) => [
  createQueryKey("createSpace", options),
];

export const createSpaceOptions = (options: Options<CreateSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createSpaceQueryKey(options),
  });
};

export const createSpaceMutation = (
  options?: Partial<Options<CreateSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateSpaceResponse,
    CreateSpaceError,
    Options<CreateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteSpaceMutation = (
  options?: Partial<Options<DeleteSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteSpaceResponse,
    DeleteSpaceError,
    Options<DeleteSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSpaceQueryKey = (options: Options<GetSpaceData>) => [
  createQueryKey("getSpace", options),
];

export const getSpaceOptions = (options: Options<GetSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSpaceQueryKey(options),
  });
};

export const updateSpaceMutation = (
  options?: Partial<Options<UpdateSpaceData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateSpaceResponse,
    UpdateSpaceError,
    Options<UpdateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listUserSshkeysQueryKey = (
  options?: Options<ListUserSshkeysData>
) => [createQueryKey("listUserSshkeys", options)];

export const listUserSshkeysOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUserSshkeysQueryKey(options),
  });
};

export const listUserSshkeysInfiniteQueryKey = (
  options?: Options<ListUserSshkeysData>
): QueryKey<Options<ListUserSshkeysData>> => [
  createQueryKey("listUserSshkeys", options, true),
];

export const listUserSshkeysInfiniteOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return infiniteQueryOptions<
    ListUserSshkeysResponse,
    ListUserSshkeysError,
    InfiniteData<ListUserSshkeysResponse>,
    QueryKey<Options<ListUserSshkeysData>>,
    | number
    | Pick<
        QueryKey<Options<ListUserSshkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUserSshkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUserSshkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUserSshkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSshkeysQueryKey = (
  options: Options<CreateUserSshkeysData>
) => [createQueryKey("createUserSshkeys", options)];

export const createUserSshkeysOptions = (
  options: Options<CreateUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSshkeysQueryKey(options),
  });
};

export const createUserSshkeysMutation = (
  options?: Partial<Options<CreateUserSshkeysData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserSshkeysResponse,
    CreateUserSshkeysError,
    Options<CreateUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserSshkeyMutation = (
  options?: Partial<Options<DeleteUserSshkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSshkeyResponse,
    DeleteUserSshkeyError,
    Options<DeleteUserSshkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSshkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSshkeyQueryKey = (options: Options<GetUserSshkeyData>) => [
  createQueryKey("getUserSshkey", options),
];

export const getUserSshkeyOptions = (options: Options<GetUserSshkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSshkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSshkeyQueryKey(options),
  });
};

export const importUserSshkeysQueryKey = (
  options: Options<ImportUserSshkeysData>
) => [createQueryKey("importUserSshkeys", options)];

export const importUserSshkeysOptions = (
  options: Options<ImportUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: importUserSshkeysQueryKey(options),
  });
};

export const importUserSshkeysMutation = (
  options?: Partial<Options<ImportUserSshkeysData>>
) => {
  const mutationOptions: UseMutationOptions<
    ImportUserSshkeysResponse,
    ImportUserSshkeysError,
    Options<ImportUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeysQueryKey = (
  options?: Options<GetUserSslkeysData>
) => [createQueryKey("getUserSslkeys", options)];

export const getUserSslkeysOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeysQueryKey(options),
  });
};

export const getUserSslkeysInfiniteQueryKey = (
  options?: Options<GetUserSslkeysData>
): QueryKey<Options<GetUserSslkeysData>> => [
  createQueryKey("getUserSslkeys", options, true),
];

export const getUserSslkeysInfiniteOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return infiniteQueryOptions<
    GetUserSslkeysResponse,
    GetUserSslkeysError,
    InfiniteData<GetUserSslkeysResponse>,
    QueryKey<Options<GetUserSslkeysData>>,
    | number
    | Pick<
        QueryKey<Options<GetUserSslkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserSslkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserSslkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserSslkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSslkeyQueryKey = (
  options: Options<CreateUserSslkeyData>
) => [createQueryKey("createUserSslkey", options)];

export const createUserSslkeyOptions = (
  options: Options<CreateUserSslkeyData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSslkeyQueryKey(options),
  });
};

export const createUserSslkeyMutation = (
  options?: Partial<Options<CreateUserSslkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserSslkeyResponse,
    CreateUserSslkeyError,
    Options<CreateUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserSslkeyMutation = (
  options?: Partial<Options<DeleteUserSslkeyData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSslkeyResponse,
    DeleteUserSslkeyError,
    Options<DeleteUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeyQueryKey = (options: Options<GetUserSslkeyData>) => [
  createQueryKey("getUserSslkey", options),
];

export const getUserSslkeyOptions = (options: Options<GetUserSslkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeyQueryKey(options),
  });
};

export const listFabricVlanSubnetsQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
) => [createQueryKey("listFabricVlanSubnets", options)];

export const listFabricVlanSubnetsOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetsQueryKey(options),
  });
};

export const listFabricVlanSubnetsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
): QueryKey<Options<ListFabricVlanSubnetsData>> => [
  createQueryKey("listFabricVlanSubnets", options, true),
];

export const listFabricVlanSubnetsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetsResponse,
    ListFabricVlanSubnetsError,
    InfiniteData<ListFabricVlanSubnetsResponse>,
    QueryKey<Options<ListFabricVlanSubnetsData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnets({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetQueryKey = (
  options: Options<CreateFabricVlanSubnetData>
) => [createQueryKey("createFabricVlanSubnet", options)];

export const createFabricVlanSubnetOptions = (
  options: Options<CreateFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetQueryKey(options),
  });
};

export const createFabricVlanSubnetMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetResponse,
    CreateFabricVlanSubnetError,
    Options<CreateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanSubnetMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetResponse,
    DeleteFabricVlanSubnetError,
    Options<DeleteFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateFabricVlanSubnetMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetResponse,
    UpdateFabricVlanSubnetError,
    Options<UpdateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetQueryKey = (
  options: Options<GetFabricVlanSubnetData>
) => [createQueryKey("getFabricVlanSubnet", options)];

export const getFabricVlanSubnetOptions = (
  options: Options<GetFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetQueryKey(options),
  });
};

export const getUserInfoQueryKey = (options?: Options<GetUserInfoData>) => [
  createQueryKey("getUserInfo", options),
];

export const getUserInfoOptions = (options?: Options<GetUserInfoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserInfoQueryKey(options),
  });
};

export const listUsersQueryKey = (options?: Options<ListUsersData>) => [
  createQueryKey("listUsers", options),
];

export const listUsersOptions = (options?: Options<ListUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUsersQueryKey(options),
  });
};

export const listUsersInfiniteQueryKey = (
  options?: Options<ListUsersData>
): QueryKey<Options<ListUsersData>> => [
  createQueryKey("listUsers", options, true),
];

export const listUsersInfiniteOptions = (options?: Options<ListUsersData>) => {
  return infiniteQueryOptions<
    ListUsersResponse,
    ListUsersError,
    InfiniteData<ListUsersResponse>,
    QueryKey<Options<ListUsersData>>,
    | number
    | Pick<
        QueryKey<Options<ListUsersData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUsersData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUsersInfiniteQueryKey(options),
    }
  );
};

export const createUserQueryKey = (options: Options<CreateUserData>) => [
  createQueryKey("createUser", options),
];

export const createUserOptions = (options: Options<CreateUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserQueryKey(options),
  });
};

export const createUserMutation = (
  options?: Partial<Options<CreateUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateUserResponse,
    CreateUserError,
    Options<CreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserQueryKey = (options: Options<GetUserData>) => [
  createQueryKey("getUser", options),
];

export const getUserOptions = (options: Options<GetUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserQueryKey(options),
  });
};

export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listFabricVlansQueryKey = (
  options: Options<ListFabricVlansData>
) => [createQueryKey("listFabricVlans", options)];

export const listFabricVlansOptions = (
  options: Options<ListFabricVlansData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlans({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlansQueryKey(options),
  });
};

export const listFabricVlansInfiniteQueryKey = (
  options: Options<ListFabricVlansData>
): QueryKey<Options<ListFabricVlansData>> => [
  createQueryKey("listFabricVlans", options, true),
];

export const listFabricVlansInfiniteOptions = (
  options: Options<ListFabricVlansData>
) => {
  return infiniteQueryOptions<
    ListFabricVlansResponse,
    ListFabricVlansError,
    InfiniteData<ListFabricVlansResponse>,
    QueryKey<Options<ListFabricVlansData>>,
    | number
    | Pick<
        QueryKey<Options<ListFabricVlansData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlansData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlans({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlansInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanQueryKey = (
  options: Options<CreateFabricVlanData>
) => [createQueryKey("createFabricVlan", options)];

export const createFabricVlanOptions = (
  options: Options<CreateFabricVlanData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanQueryKey(options),
  });
};

export const createFabricVlanMutation = (
  options?: Partial<Options<CreateFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanResponse,
    CreateFabricVlanError,
    Options<CreateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteFabricVlanMutation = (
  options?: Partial<Options<DeleteFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanResponse,
    DeleteFabricVlanError,
    Options<DeleteFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanQueryKey = (options: Options<GetFabricVlanData>) => [
  createQueryKey("getFabricVlan", options),
];

export const getFabricVlanOptions = (options: Options<GetFabricVlanData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanQueryKey(options),
  });
};

export const updateFabricVlanMutation = (
  options?: Partial<Options<UpdateFabricVlanData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanResponse,
    UpdateFabricVlanError,
    Options<UpdateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesQueryKey = (options?: Options<ListZonesData>) => [
  createQueryKey("listZones", options),
];

export const listZonesOptions = (options?: Options<ListZonesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZones({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesQueryKey(options),
  });
};

export const listZonesInfiniteQueryKey = (
  options?: Options<ListZonesData>
): QueryKey<Options<ListZonesData>> => [
  createQueryKey("listZones", options, true),
];

export const listZonesInfiniteOptions = (options?: Options<ListZonesData>) => {
  return infiniteQueryOptions<
    ListZonesResponse,
    ListZonesError,
    InfiniteData<ListZonesResponse>,
    QueryKey<Options<ListZonesData>>,
    | number
    | Pick<
        QueryKey<Options<ListZonesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZones({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesInfiniteQueryKey(options),
    }
  );
};

export const createZoneQueryKey = (options: Options<CreateZoneData>) => [
  createQueryKey("createZone", options),
];

export const createZoneOptions = (options: Options<CreateZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createZoneQueryKey(options),
  });
};

export const createZoneMutation = (
  options?: Partial<Options<CreateZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    CreateZoneResponse,
    CreateZoneError,
    Options<CreateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const deleteZoneMutation = (
  options?: Partial<Options<DeleteZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    DeleteZoneResponse,
    DeleteZoneError,
    Options<DeleteZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getZoneQueryKey = (options: Options<GetZoneData>) => [
  createQueryKey("getZone", options),
];

export const getZoneOptions = (options: Options<GetZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getZoneQueryKey(options),
  });
};

export const updateZoneMutation = (
  options?: Partial<Options<UpdateZoneData>>
) => {
  const mutationOptions: UseMutationOptions<
    UpdateZoneResponse,
    UpdateZoneError,
    Options<UpdateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesWithSummaryQueryKey = (
  options?: Options<ListZonesWithSummaryData>
) => [createQueryKey("listZonesWithSummary", options)];

export const listZonesWithSummaryOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZonesWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesWithSummaryQueryKey(options),
  });
};

export const listZonesWithSummaryInfiniteQueryKey = (
  options?: Options<ListZonesWithSummaryData>
): QueryKey<Options<ListZonesWithSummaryData>> => [
  createQueryKey("listZonesWithSummary", options, true),
];

export const listZonesWithSummaryInfiniteOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListZonesWithSummaryResponse,
    ListZonesWithSummaryError,
    InfiniteData<ListZonesWithSummaryResponse>,
    QueryKey<Options<ListZonesWithSummaryData>>,
    | number
    | Pick<
        QueryKey<Options<ListZonesWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZonesWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesWithSummaryInfiniteQueryKey(options),
    }
  );
};
