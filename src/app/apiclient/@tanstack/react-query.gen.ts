// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  accessToken,
  login,
  getConfiguration,
  setConfiguration,
  getConfigurations,
  setConfigurations,
  listEvents,
  clearAllDiscoveriesWithOptionalIpAndMac,
  listDiscoveries,
  clearNeighboursDiscoveries,
  clearRdnsAndMdnsDiscoveries,
  getDiscovery,
  listDomains,
  createDomain,
  getDomainRrsets,
  createDomainRrsets,
  deleteDomain,
  getDomain,
  listFabrics,
  createFabric,
  deleteFabric,
  getFabric,
  updateFabric,
  listInterfaces,
  listFabricVlanSubnetIprange,
  createFabricVlanSubnetIprange,
  deleteFabricVlanSubnetIprange,
  updateFabricVlanSubnetIprange,
  getFabricVlanSubnetIprange,
  getMachinePowerParameters,
  listMachinePciDevices,
  listMachineUsbDevices,
  listMachines,
  listNotifications,
  createNotification,
  deleteNotification,
  getNotification,
  updateNotification,
  dismissNotification,
  listPackageRepositories,
  createPackageRepository,
  deletePackageRepository,
  getPackageRepository,
  updatePackageRepository,
  listFabricVlanSubnetReservedIps,
  createFabricVlanSubnetReservedIp,
  deleteFabricVlanSubnetReservedIp,
  updateFabricVlanSubnetReservedIp,
  getFabricVlanSubnetReservedIp,
  listResourcePools,
  createResourcePool,
  deleteResourcePool,
  getResourcePool,
  updateResourcePool,
  listResourcePoolsWithSummary,
  listFabricVlanSubnetStaticroutes,
  createFabricVlanSubnetStaticroute,
  deleteFabricVlanSubnetStaticroute,
  getFabricVlanSubnetStaticroute,
  updateFabricVlanSubnetStaticroute,
  listSpaces,
  createSpace,
  deleteSpace,
  getSpace,
  updateSpace,
  listUserSshkeys,
  createUserSshkeys,
  deleteUserSshkey,
  getUserSshkey,
  importUserSshkeys,
  getUserSslkeys,
  createUserSslkey,
  deleteUserSslkey,
  getUserSslkey,
  getUserSslkeysWithSummary,
  listFabricVlanSubnets,
  createFabricVlanSubnet,
  deleteFabricVlanSubnet,
  updateFabricVlanSubnet,
  getFabricVlanSubnet,
  listTags,
  createTag,
  deleteTag,
  getTag,
  updateTag,
  getMeWithSummary,
  getUserInfo,
  completeIntro,
  changePasswordUser,
  listUsers,
  createUser,
  deleteUser,
  getUser,
  updateUser,
  changePasswordAdmin,
  listUsersWithSummary,
  listFabricVlans,
  createFabricVlan,
  deleteFabricVlan,
  getFabricVlan,
  updateFabricVlan,
  listZones,
  createZone,
  deleteZone,
  getZone,
  updateZone,
  listZonesWithSummary,
} from "../sdk.gen";
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query";
import type {
  AccessTokenData,
  LoginData,
  LoginError,
  LoginResponse,
  GetConfigurationData,
  SetConfigurationData,
  SetConfigurationError,
  SetConfigurationResponse,
  GetConfigurationsData,
  SetConfigurationsData,
  SetConfigurationsError,
  SetConfigurationsResponse,
  ListEventsData,
  ListEventsError,
  ListEventsResponse,
  ClearAllDiscoveriesWithOptionalIpAndMacData,
  ClearAllDiscoveriesWithOptionalIpAndMacError,
  ClearAllDiscoveriesWithOptionalIpAndMacResponse,
  ListDiscoveriesData,
  ListDiscoveriesError,
  ListDiscoveriesResponse,
  ClearNeighboursDiscoveriesData,
  ClearNeighboursDiscoveriesError,
  ClearNeighboursDiscoveriesResponse,
  ClearRdnsAndMdnsDiscoveriesData,
  ClearRdnsAndMdnsDiscoveriesError,
  ClearRdnsAndMdnsDiscoveriesResponse,
  GetDiscoveryData,
  ListDomainsData,
  ListDomainsError,
  ListDomainsResponse,
  CreateDomainData,
  CreateDomainError,
  CreateDomainResponse,
  GetDomainRrsetsData,
  CreateDomainRrsetsData,
  CreateDomainRrsetsError,
  CreateDomainRrsetsResponse,
  DeleteDomainData,
  DeleteDomainError,
  DeleteDomainResponse,
  GetDomainData,
  ListFabricsData,
  ListFabricsError,
  ListFabricsResponse,
  CreateFabricData,
  CreateFabricError,
  CreateFabricResponse,
  DeleteFabricData,
  DeleteFabricError,
  DeleteFabricResponse,
  GetFabricData,
  UpdateFabricData,
  UpdateFabricError,
  UpdateFabricResponse,
  ListInterfacesData,
  ListInterfacesError,
  ListInterfacesResponse,
  ListFabricVlanSubnetIprangeData,
  ListFabricVlanSubnetIprangeError,
  ListFabricVlanSubnetIprangeResponse,
  CreateFabricVlanSubnetIprangeData,
  CreateFabricVlanSubnetIprangeError,
  CreateFabricVlanSubnetIprangeResponse,
  DeleteFabricVlanSubnetIprangeData,
  DeleteFabricVlanSubnetIprangeError,
  DeleteFabricVlanSubnetIprangeResponse,
  UpdateFabricVlanSubnetIprangeData,
  UpdateFabricVlanSubnetIprangeError,
  UpdateFabricVlanSubnetIprangeResponse,
  GetFabricVlanSubnetIprangeData,
  GetMachinePowerParametersData,
  ListMachinePciDevicesData,
  ListMachinePciDevicesError,
  ListMachinePciDevicesResponse,
  ListMachineUsbDevicesData,
  ListMachineUsbDevicesError,
  ListMachineUsbDevicesResponse,
  ListMachinesData,
  ListMachinesError,
  ListMachinesResponse,
  ListNotificationsData,
  ListNotificationsError,
  ListNotificationsResponse,
  CreateNotificationData,
  CreateNotificationError,
  CreateNotificationResponse,
  DeleteNotificationData,
  DeleteNotificationError,
  DeleteNotificationResponse,
  GetNotificationData,
  UpdateNotificationData,
  UpdateNotificationError,
  UpdateNotificationResponse,
  DismissNotificationData,
  DismissNotificationError,
  DismissNotificationResponse,
  ListPackageRepositoriesData,
  ListPackageRepositoriesError,
  ListPackageRepositoriesResponse,
  CreatePackageRepositoryData,
  CreatePackageRepositoryError,
  CreatePackageRepositoryResponse,
  DeletePackageRepositoryData,
  DeletePackageRepositoryError,
  DeletePackageRepositoryResponse,
  GetPackageRepositoryData,
  UpdatePackageRepositoryData,
  UpdatePackageRepositoryError,
  UpdatePackageRepositoryResponse,
  ListFabricVlanSubnetReservedIpsData,
  ListFabricVlanSubnetReservedIpsError,
  ListFabricVlanSubnetReservedIpsResponse,
  CreateFabricVlanSubnetReservedIpData,
  CreateFabricVlanSubnetReservedIpError,
  CreateFabricVlanSubnetReservedIpResponse,
  DeleteFabricVlanSubnetReservedIpData,
  DeleteFabricVlanSubnetReservedIpError,
  DeleteFabricVlanSubnetReservedIpResponse,
  UpdateFabricVlanSubnetReservedIpData,
  UpdateFabricVlanSubnetReservedIpError,
  UpdateFabricVlanSubnetReservedIpResponse,
  GetFabricVlanSubnetReservedIpData,
  ListResourcePoolsData,
  ListResourcePoolsError,
  ListResourcePoolsResponse,
  CreateResourcePoolData,
  CreateResourcePoolError,
  CreateResourcePoolResponse,
  DeleteResourcePoolData,
  DeleteResourcePoolError,
  DeleteResourcePoolResponse,
  GetResourcePoolData,
  UpdateResourcePoolData,
  UpdateResourcePoolError,
  UpdateResourcePoolResponse,
  ListResourcePoolsWithSummaryData,
  ListResourcePoolsWithSummaryError,
  ListResourcePoolsWithSummaryResponse,
  ListFabricVlanSubnetStaticroutesData,
  ListFabricVlanSubnetStaticroutesError,
  ListFabricVlanSubnetStaticroutesResponse,
  CreateFabricVlanSubnetStaticrouteData,
  CreateFabricVlanSubnetStaticrouteError,
  CreateFabricVlanSubnetStaticrouteResponse,
  DeleteFabricVlanSubnetStaticrouteData,
  DeleteFabricVlanSubnetStaticrouteError,
  DeleteFabricVlanSubnetStaticrouteResponse,
  GetFabricVlanSubnetStaticrouteData,
  UpdateFabricVlanSubnetStaticrouteData,
  UpdateFabricVlanSubnetStaticrouteError,
  UpdateFabricVlanSubnetStaticrouteResponse,
  ListSpacesData,
  ListSpacesError,
  ListSpacesResponse,
  CreateSpaceData,
  CreateSpaceError,
  CreateSpaceResponse,
  DeleteSpaceData,
  DeleteSpaceError,
  DeleteSpaceResponse,
  GetSpaceData,
  UpdateSpaceData,
  UpdateSpaceError,
  UpdateSpaceResponse,
  ListUserSshkeysData,
  ListUserSshkeysError,
  ListUserSshkeysResponse,
  CreateUserSshkeysData,
  CreateUserSshkeysError,
  CreateUserSshkeysResponse,
  DeleteUserSshkeyData,
  DeleteUserSshkeyError,
  DeleteUserSshkeyResponse,
  GetUserSshkeyData,
  ImportUserSshkeysData,
  ImportUserSshkeysError,
  ImportUserSshkeysResponse,
  GetUserSslkeysData,
  GetUserSslkeysError,
  GetUserSslkeysResponse,
  CreateUserSslkeyData,
  CreateUserSslkeyError,
  CreateUserSslkeyResponse,
  DeleteUserSslkeyData,
  DeleteUserSslkeyError,
  DeleteUserSslkeyResponse,
  GetUserSslkeyData,
  GetUserSslkeysWithSummaryData,
  GetUserSslkeysWithSummaryError,
  GetUserSslkeysWithSummaryResponse,
  ListFabricVlanSubnetsData,
  ListFabricVlanSubnetsError,
  ListFabricVlanSubnetsResponse,
  CreateFabricVlanSubnetData,
  CreateFabricVlanSubnetError,
  CreateFabricVlanSubnetResponse,
  DeleteFabricVlanSubnetData,
  DeleteFabricVlanSubnetError,
  DeleteFabricVlanSubnetResponse,
  UpdateFabricVlanSubnetData,
  UpdateFabricVlanSubnetError,
  UpdateFabricVlanSubnetResponse,
  GetFabricVlanSubnetData,
  ListTagsData,
  ListTagsError,
  ListTagsResponse,
  CreateTagData,
  CreateTagError,
  CreateTagResponse,
  DeleteTagData,
  DeleteTagError,
  DeleteTagResponse,
  GetTagData,
  UpdateTagData,
  UpdateTagError,
  UpdateTagResponse,
  GetMeWithSummaryData,
  GetUserInfoData,
  CompleteIntroData,
  CompleteIntroError,
  CompleteIntroResponse,
  ChangePasswordUserData,
  ChangePasswordUserError,
  ChangePasswordUserResponse,
  ListUsersData,
  ListUsersError,
  ListUsersResponse,
  CreateUserData,
  CreateUserError,
  CreateUserResponse,
  DeleteUserData,
  DeleteUserError,
  DeleteUserResponse,
  GetUserData,
  UpdateUserData,
  UpdateUserError,
  UpdateUserResponse,
  ChangePasswordAdminData,
  ChangePasswordAdminError,
  ChangePasswordAdminResponse,
  ListUsersWithSummaryData,
  ListUsersWithSummaryError,
  ListUsersWithSummaryResponse,
  ListFabricVlansData,
  ListFabricVlansError,
  ListFabricVlansResponse,
  CreateFabricVlanData,
  CreateFabricVlanError,
  CreateFabricVlanResponse,
  DeleteFabricVlanData,
  DeleteFabricVlanError,
  DeleteFabricVlanResponse,
  GetFabricVlanData,
  UpdateFabricVlanData,
  UpdateFabricVlanError,
  UpdateFabricVlanResponse,
  ListZonesData,
  ListZonesError,
  ListZonesResponse,
  CreateZoneData,
  CreateZoneError,
  CreateZoneResponse,
  DeleteZoneData,
  DeleteZoneError,
  DeleteZoneResponse,
  GetZoneData,
  UpdateZoneData,
  UpdateZoneError,
  UpdateZoneResponse,
  ListZonesWithSummaryData,
  ListZonesWithSummaryError,
  ListZonesWithSummaryResponse,
} from "../types.gen";
import { client as _heyApiClient } from "../client.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const accessTokenQueryKey = (options?: Options<AccessTokenData>) =>
  createQueryKey("accessToken", options);

/**
 * Access Token
 */
export const accessTokenOptions = (options?: Options<AccessTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await accessToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: accessTokenQueryKey(options),
  });
};

export const loginQueryKey = (options: Options<LoginData>) =>
  createQueryKey("login", options);

/**
 * Login
 */
export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginQueryKey(options),
  });
};

/**
 * Login
 */
export const loginMutation = (
  options?: Partial<Options<LoginData>>
): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
  const mutationOptions: UseMutationOptions<
    LoginResponse,
    LoginError,
    Options<LoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await login({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getConfigurationQueryKey = (
  options: Options<GetConfigurationData>
) => createQueryKey("getConfiguration", options);

/**
 * Get Configuration
 */
export const getConfigurationOptions = (
  options: Options<GetConfigurationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getConfigurationQueryKey(options),
  });
};

/**
 * Set Configuration
 */
export const setConfigurationMutation = (
  options?: Partial<Options<SetConfigurationData>>
): UseMutationOptions<
  SetConfigurationResponse,
  SetConfigurationError,
  Options<SetConfigurationData>
> => {
  const mutationOptions: UseMutationOptions<
    SetConfigurationResponse,
    SetConfigurationError,
    Options<SetConfigurationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await setConfiguration({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getConfigurationsQueryKey = (
  options?: Options<GetConfigurationsData>
) => createQueryKey("getConfigurations", options);

/**
 * Get Configurations
 */
export const getConfigurationsOptions = (
  options?: Options<GetConfigurationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getConfigurations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getConfigurationsQueryKey(options),
  });
};

/**
 * Set Configurations
 */
export const setConfigurationsMutation = (
  options?: Partial<Options<SetConfigurationsData>>
): UseMutationOptions<
  SetConfigurationsResponse,
  SetConfigurationsError,
  Options<SetConfigurationsData>
> => {
  const mutationOptions: UseMutationOptions<
    SetConfigurationsResponse,
    SetConfigurationsError,
    Options<SetConfigurationsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await setConfigurations({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listEventsQueryKey = (options?: Options<ListEventsData>) =>
  createQueryKey("listEvents", options);

/**
 * List Events
 */
export const listEventsOptions = (options?: Options<ListEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listEventsQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listEventsInfiniteQueryKey = (
  options?: Options<ListEventsData>
): QueryKey<Options<ListEventsData>> =>
  createQueryKey("listEvents", options, true);

/**
 * List Events
 */
export const listEventsInfiniteOptions = (
  options?: Options<ListEventsData>
) => {
  return infiniteQueryOptions<
    ListEventsResponse,
    ListEventsError,
    InfiniteData<ListEventsResponse>,
    QueryKey<Options<ListEventsData>>,
    | Pick<
        QueryKey<Options<ListEventsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListEventsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listEvents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listEventsInfiniteQueryKey(options),
    }
  );
};

/**
 * Clear All Discoveries With Optional Ip And Mac
 */
export const clearAllDiscoveriesWithOptionalIpAndMacMutation = (
  options?: Partial<Options<ClearAllDiscoveriesWithOptionalIpAndMacData>>
): UseMutationOptions<
  ClearAllDiscoveriesWithOptionalIpAndMacResponse,
  ClearAllDiscoveriesWithOptionalIpAndMacError,
  Options<ClearAllDiscoveriesWithOptionalIpAndMacData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearAllDiscoveriesWithOptionalIpAndMacResponse,
    ClearAllDiscoveriesWithOptionalIpAndMacError,
    Options<ClearAllDiscoveriesWithOptionalIpAndMacData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await clearAllDiscoveriesWithOptionalIpAndMac({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listDiscoveriesQueryKey = (
  options?: Options<ListDiscoveriesData>
) => createQueryKey("listDiscoveries", options);

/**
 * List Discoveries
 */
export const listDiscoveriesOptions = (
  options?: Options<ListDiscoveriesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listDiscoveries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listDiscoveriesQueryKey(options),
  });
};

export const listDiscoveriesInfiniteQueryKey = (
  options?: Options<ListDiscoveriesData>
): QueryKey<Options<ListDiscoveriesData>> =>
  createQueryKey("listDiscoveries", options, true);

/**
 * List Discoveries
 */
export const listDiscoveriesInfiniteOptions = (
  options?: Options<ListDiscoveriesData>
) => {
  return infiniteQueryOptions<
    ListDiscoveriesResponse,
    ListDiscoveriesError,
    InfiniteData<ListDiscoveriesResponse>,
    QueryKey<Options<ListDiscoveriesData>>,
    | Pick<
        QueryKey<Options<ListDiscoveriesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListDiscoveriesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDiscoveries({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listDiscoveriesInfiniteQueryKey(options),
    }
  );
};

/**
 * Clear Neighbours Discoveries
 */
export const clearNeighboursDiscoveriesMutation = (
  options?: Partial<Options<ClearNeighboursDiscoveriesData>>
): UseMutationOptions<
  ClearNeighboursDiscoveriesResponse,
  ClearNeighboursDiscoveriesError,
  Options<ClearNeighboursDiscoveriesData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearNeighboursDiscoveriesResponse,
    ClearNeighboursDiscoveriesError,
    Options<ClearNeighboursDiscoveriesData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await clearNeighboursDiscoveries({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Clear Rdns And Mdns Discoveries
 */
export const clearRdnsAndMdnsDiscoveriesMutation = (
  options?: Partial<Options<ClearRdnsAndMdnsDiscoveriesData>>
): UseMutationOptions<
  ClearRdnsAndMdnsDiscoveriesResponse,
  ClearRdnsAndMdnsDiscoveriesError,
  Options<ClearRdnsAndMdnsDiscoveriesData>
> => {
  const mutationOptions: UseMutationOptions<
    ClearRdnsAndMdnsDiscoveriesResponse,
    ClearRdnsAndMdnsDiscoveriesError,
    Options<ClearRdnsAndMdnsDiscoveriesData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await clearRdnsAndMdnsDiscoveries({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDiscoveryQueryKey = (options: Options<GetDiscoveryData>) =>
  createQueryKey("getDiscovery", options);

/**
 * Get Discovery
 */
export const getDiscoveryOptions = (options: Options<GetDiscoveryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDiscovery({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDiscoveryQueryKey(options),
  });
};

export const listDomainsQueryKey = (options?: Options<ListDomainsData>) =>
  createQueryKey("listDomains", options);

/**
 * List Domains
 */
export const listDomainsOptions = (options?: Options<ListDomainsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listDomains({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listDomainsQueryKey(options),
  });
};

export const listDomainsInfiniteQueryKey = (
  options?: Options<ListDomainsData>
): QueryKey<Options<ListDomainsData>> =>
  createQueryKey("listDomains", options, true);

/**
 * List Domains
 */
export const listDomainsInfiniteOptions = (
  options?: Options<ListDomainsData>
) => {
  return infiniteQueryOptions<
    ListDomainsResponse,
    ListDomainsError,
    InfiniteData<ListDomainsResponse>,
    QueryKey<Options<ListDomainsData>>,
    | Pick<
        QueryKey<Options<ListDomainsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListDomainsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDomains({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listDomainsInfiniteQueryKey(options),
    }
  );
};

export const createDomainQueryKey = (options: Options<CreateDomainData>) =>
  createQueryKey("createDomain", options);

/**
 * Create Domain
 */
export const createDomainOptions = (options: Options<CreateDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDomainQueryKey(options),
  });
};

/**
 * Create Domain
 */
export const createDomainMutation = (
  options?: Partial<Options<CreateDomainData>>
): UseMutationOptions<
  CreateDomainResponse,
  CreateDomainError,
  Options<CreateDomainData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDomainResponse,
    CreateDomainError,
    Options<CreateDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDomainRrsetsQueryKey = (
  options: Options<GetDomainRrsetsData>
) => createQueryKey("getDomainRrsets", options);

/**
 * Get Domain Rrsets
 */
export const getDomainRrsetsOptions = (
  options: Options<GetDomainRrsetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDomainRrsets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDomainRrsetsQueryKey(options),
  });
};

export const createDomainRrsetsQueryKey = (
  options: Options<CreateDomainRrsetsData>
) => createQueryKey("createDomainRrsets", options);

/**
 * Create Domain Rrsets
 */
export const createDomainRrsetsOptions = (
  options: Options<CreateDomainRrsetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createDomainRrsets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createDomainRrsetsQueryKey(options),
  });
};

/**
 * Create Domain Rrsets
 */
export const createDomainRrsetsMutation = (
  options?: Partial<Options<CreateDomainRrsetsData>>
): UseMutationOptions<
  CreateDomainRrsetsResponse,
  CreateDomainRrsetsError,
  Options<CreateDomainRrsetsData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDomainRrsetsResponse,
    CreateDomainRrsetsError,
    Options<CreateDomainRrsetsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createDomainRrsets({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Domain
 */
export const deleteDomainMutation = (
  options?: Partial<Options<DeleteDomainData>>
): UseMutationOptions<
  DeleteDomainResponse,
  DeleteDomainError,
  Options<DeleteDomainData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteDomainResponse,
    DeleteDomainError,
    Options<DeleteDomainData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteDomain({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getDomainQueryKey = (options: Options<GetDomainData>) =>
  createQueryKey("getDomain", options);

/**
 * Get Domain
 */
export const getDomainOptions = (options: Options<GetDomainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDomain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDomainQueryKey(options),
  });
};

export const listFabricsQueryKey = (options?: Options<ListFabricsData>) =>
  createQueryKey("listFabrics", options);

/**
 * List Fabrics
 */
export const listFabricsOptions = (options?: Options<ListFabricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricsQueryKey(options),
  });
};

export const listFabricsInfiniteQueryKey = (
  options?: Options<ListFabricsData>
): QueryKey<Options<ListFabricsData>> =>
  createQueryKey("listFabrics", options, true);

/**
 * List Fabrics
 */
export const listFabricsInfiniteOptions = (
  options?: Options<ListFabricsData>
) => {
  return infiniteQueryOptions<
    ListFabricsResponse,
    ListFabricsError,
    InfiniteData<ListFabricsResponse>,
    QueryKey<Options<ListFabricsData>>,
    | Pick<
        QueryKey<Options<ListFabricsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabrics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricsInfiniteQueryKey(options),
    }
  );
};

export const createFabricQueryKey = (options: Options<CreateFabricData>) =>
  createQueryKey("createFabric", options);

/**
 * Create Fabric
 */
export const createFabricOptions = (options: Options<CreateFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricQueryKey(options),
  });
};

/**
 * Create Fabric
 */
export const createFabricMutation = (
  options?: Partial<Options<CreateFabricData>>
): UseMutationOptions<
  CreateFabricResponse,
  CreateFabricError,
  Options<CreateFabricData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricResponse,
    CreateFabricError,
    Options<CreateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric
 */
export const deleteFabricMutation = (
  options?: Partial<Options<DeleteFabricData>>
): UseMutationOptions<
  DeleteFabricResponse,
  DeleteFabricError,
  Options<DeleteFabricData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricResponse,
    DeleteFabricError,
    Options<DeleteFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricQueryKey = (options: Options<GetFabricData>) =>
  createQueryKey("getFabric", options);

/**
 * Get Fabric
 */
export const getFabricOptions = (options: Options<GetFabricData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabric({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricQueryKey(options),
  });
};

/**
 * Update Fabric
 */
export const updateFabricMutation = (
  options?: Partial<Options<UpdateFabricData>>
): UseMutationOptions<
  UpdateFabricResponse,
  UpdateFabricError,
  Options<UpdateFabricData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricResponse,
    UpdateFabricError,
    Options<UpdateFabricData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabric({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listInterfacesQueryKey = (options: Options<ListInterfacesData>) =>
  createQueryKey("listInterfaces", options);

/**
 * List Interfaces
 */
export const listInterfacesOptions = (options: Options<ListInterfacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listInterfaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listInterfacesQueryKey(options),
  });
};

export const listInterfacesInfiniteQueryKey = (
  options: Options<ListInterfacesData>
): QueryKey<Options<ListInterfacesData>> =>
  createQueryKey("listInterfaces", options, true);

/**
 * List Interfaces
 */
export const listInterfacesInfiniteOptions = (
  options: Options<ListInterfacesData>
) => {
  return infiniteQueryOptions<
    ListInterfacesResponse,
    ListInterfacesError,
    InfiniteData<ListInterfacesResponse>,
    QueryKey<Options<ListInterfacesData>>,
    | Pick<
        QueryKey<Options<ListInterfacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListInterfacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listInterfaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listInterfacesInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetIprangeQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => createQueryKey("listFabricVlanSubnetIprange", options);

/**
 * List Fabric Vlan Subnet Iprange
 */
export const listFabricVlanSubnetIprangeOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const listFabricVlanSubnetIprangeInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetIprangeData>
): QueryKey<Options<ListFabricVlanSubnetIprangeData>> =>
  createQueryKey("listFabricVlanSubnetIprange", options, true);

/**
 * List Fabric Vlan Subnet Iprange
 */
export const listFabricVlanSubnetIprangeInfiniteOptions = (
  options: Options<ListFabricVlanSubnetIprangeData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetIprangeResponse,
    ListFabricVlanSubnetIprangeError,
    InfiniteData<ListFabricVlanSubnetIprangeResponse>,
    QueryKey<Options<ListFabricVlanSubnetIprangeData>>,
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetIprangeData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetIprange({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetIprangeInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetIprangeQueryKey = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => createQueryKey("createFabricVlanSubnetIprange", options);

/**
 * Create Fabric Vlan Subnet Iprange
 */
export const createFabricVlanSubnetIprangeOptions = (
  options: Options<CreateFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetIprangeQueryKey(options),
  });
};

/**
 * Create Fabric Vlan Subnet Iprange
 */
export const createFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetIprangeData>>
): UseMutationOptions<
  CreateFabricVlanSubnetIprangeResponse,
  CreateFabricVlanSubnetIprangeError,
  Options<CreateFabricVlanSubnetIprangeData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetIprangeResponse,
    CreateFabricVlanSubnetIprangeError,
    Options<CreateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric Vlan Subnet Iprange
 */
export const deleteFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetIprangeData>>
): UseMutationOptions<
  DeleteFabricVlanSubnetIprangeResponse,
  DeleteFabricVlanSubnetIprangeError,
  Options<DeleteFabricVlanSubnetIprangeData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetIprangeResponse,
    DeleteFabricVlanSubnetIprangeError,
    Options<DeleteFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Fabric Vlan Subnet Iprange
 */
export const updateFabricVlanSubnetIprangeMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetIprangeData>>
): UseMutationOptions<
  UpdateFabricVlanSubnetIprangeResponse,
  UpdateFabricVlanSubnetIprangeError,
  Options<UpdateFabricVlanSubnetIprangeData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetIprangeResponse,
    UpdateFabricVlanSubnetIprangeError,
    Options<UpdateFabricVlanSubnetIprangeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetIprange({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetIprangeQueryKey = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => createQueryKey("getFabricVlanSubnetIprange", options);

/**
 * Get Fabric Vlan Subnet Iprange
 */
export const getFabricVlanSubnetIprangeOptions = (
  options: Options<GetFabricVlanSubnetIprangeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetIprange({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetIprangeQueryKey(options),
  });
};

export const getMachinePowerParametersQueryKey = (
  options: Options<GetMachinePowerParametersData>
) => createQueryKey("getMachinePowerParameters", options);

/**
 * Get Machine Power Parameters
 */
export const getMachinePowerParametersOptions = (
  options: Options<GetMachinePowerParametersData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMachinePowerParameters({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMachinePowerParametersQueryKey(options),
  });
};

export const listMachinePciDevicesQueryKey = (
  options: Options<ListMachinePciDevicesData>
) => createQueryKey("listMachinePciDevices", options);

/**
 * List Machine Pci Devices
 */
export const listMachinePciDevicesOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachinePciDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinePciDevicesQueryKey(options),
  });
};

export const listMachinePciDevicesInfiniteQueryKey = (
  options: Options<ListMachinePciDevicesData>
): QueryKey<Options<ListMachinePciDevicesData>> =>
  createQueryKey("listMachinePciDevices", options, true);

/**
 * List Machine Pci Devices
 */
export const listMachinePciDevicesInfiniteOptions = (
  options: Options<ListMachinePciDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachinePciDevicesResponse,
    ListMachinePciDevicesError,
    InfiniteData<ListMachinePciDevicesResponse>,
    QueryKey<Options<ListMachinePciDevicesData>>,
    | Pick<
        QueryKey<Options<ListMachinePciDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinePciDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachinePciDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinePciDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachineUsbDevicesQueryKey = (
  options: Options<ListMachineUsbDevicesData>
) => createQueryKey("listMachineUsbDevices", options);

/**
 * List Machine Usb Devices
 */
export const listMachineUsbDevicesOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachineUsbDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachineUsbDevicesQueryKey(options),
  });
};

export const listMachineUsbDevicesInfiniteQueryKey = (
  options: Options<ListMachineUsbDevicesData>
): QueryKey<Options<ListMachineUsbDevicesData>> =>
  createQueryKey("listMachineUsbDevices", options, true);

/**
 * List Machine Usb Devices
 */
export const listMachineUsbDevicesInfiniteOptions = (
  options: Options<ListMachineUsbDevicesData>
) => {
  return infiniteQueryOptions<
    ListMachineUsbDevicesResponse,
    ListMachineUsbDevicesError,
    InfiniteData<ListMachineUsbDevicesResponse>,
    QueryKey<Options<ListMachineUsbDevicesData>>,
    | Pick<
        QueryKey<Options<ListMachineUsbDevicesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachineUsbDevicesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachineUsbDevices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachineUsbDevicesInfiniteQueryKey(options),
    }
  );
};

export const listMachinesQueryKey = (options?: Options<ListMachinesData>) =>
  createQueryKey("listMachines", options);

/**
 * List Machines
 */
export const listMachinesOptions = (options?: Options<ListMachinesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listMachines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listMachinesQueryKey(options),
  });
};

export const listMachinesInfiniteQueryKey = (
  options?: Options<ListMachinesData>
): QueryKey<Options<ListMachinesData>> =>
  createQueryKey("listMachines", options, true);

/**
 * List Machines
 */
export const listMachinesInfiniteOptions = (
  options?: Options<ListMachinesData>
) => {
  return infiniteQueryOptions<
    ListMachinesResponse,
    ListMachinesError,
    InfiniteData<ListMachinesResponse>,
    QueryKey<Options<ListMachinesData>>,
    | Pick<
        QueryKey<Options<ListMachinesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListMachinesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMachines({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listMachinesInfiniteQueryKey(options),
    }
  );
};

export const listNotificationsQueryKey = (
  options?: Options<ListNotificationsData>
) => createQueryKey("listNotifications", options);

/**
 * List Notifications
 */
export const listNotificationsOptions = (
  options?: Options<ListNotificationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listNotifications({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listNotificationsQueryKey(options),
  });
};

export const listNotificationsInfiniteQueryKey = (
  options?: Options<ListNotificationsData>
): QueryKey<Options<ListNotificationsData>> =>
  createQueryKey("listNotifications", options, true);

/**
 * List Notifications
 */
export const listNotificationsInfiniteOptions = (
  options?: Options<ListNotificationsData>
) => {
  return infiniteQueryOptions<
    ListNotificationsResponse,
    ListNotificationsError,
    InfiniteData<ListNotificationsResponse>,
    QueryKey<Options<ListNotificationsData>>,
    | Pick<
        QueryKey<Options<ListNotificationsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListNotificationsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listNotifications({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listNotificationsInfiniteQueryKey(options),
    }
  );
};

export const createNotificationQueryKey = (
  options: Options<CreateNotificationData>
) => createQueryKey("createNotification", options);

/**
 * Create Notification
 */
export const createNotificationOptions = (
  options: Options<CreateNotificationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createNotification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createNotificationQueryKey(options),
  });
};

/**
 * Create Notification
 */
export const createNotificationMutation = (
  options?: Partial<Options<CreateNotificationData>>
): UseMutationOptions<
  CreateNotificationResponse,
  CreateNotificationError,
  Options<CreateNotificationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateNotificationResponse,
    CreateNotificationError,
    Options<CreateNotificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createNotification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Notification
 */
export const deleteNotificationMutation = (
  options?: Partial<Options<DeleteNotificationData>>
): UseMutationOptions<
  DeleteNotificationResponse,
  DeleteNotificationError,
  Options<DeleteNotificationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteNotificationResponse,
    DeleteNotificationError,
    Options<DeleteNotificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteNotification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getNotificationQueryKey = (
  options: Options<GetNotificationData>
) => createQueryKey("getNotification", options);

/**
 * Get Notification
 */
export const getNotificationOptions = (
  options: Options<GetNotificationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNotification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNotificationQueryKey(options),
  });
};

/**
 * Update Notification
 */
export const updateNotificationMutation = (
  options?: Partial<Options<UpdateNotificationData>>
): UseMutationOptions<
  UpdateNotificationResponse,
  UpdateNotificationError,
  Options<UpdateNotificationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateNotificationResponse,
    UpdateNotificationError,
    Options<UpdateNotificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateNotification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const dismissNotificationQueryKey = (
  options: Options<DismissNotificationData>
) => createQueryKey("dismissNotification", options);

/**
 * Dismiss Notification
 */
export const dismissNotificationOptions = (
  options: Options<DismissNotificationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await dismissNotification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: dismissNotificationQueryKey(options),
  });
};

/**
 * Dismiss Notification
 */
export const dismissNotificationMutation = (
  options?: Partial<Options<DismissNotificationData>>
): UseMutationOptions<
  DismissNotificationResponse,
  DismissNotificationError,
  Options<DismissNotificationData>
> => {
  const mutationOptions: UseMutationOptions<
    DismissNotificationResponse,
    DismissNotificationError,
    Options<DismissNotificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await dismissNotification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listPackageRepositoriesQueryKey = (
  options?: Options<ListPackageRepositoriesData>
) => createQueryKey("listPackageRepositories", options);

/**
 * List Package Repositories
 */
export const listPackageRepositoriesOptions = (
  options?: Options<ListPackageRepositoriesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listPackageRepositories({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listPackageRepositoriesQueryKey(options),
  });
};

export const listPackageRepositoriesInfiniteQueryKey = (
  options?: Options<ListPackageRepositoriesData>
): QueryKey<Options<ListPackageRepositoriesData>> =>
  createQueryKey("listPackageRepositories", options, true);

/**
 * List Package Repositories
 */
export const listPackageRepositoriesInfiniteOptions = (
  options?: Options<ListPackageRepositoriesData>
) => {
  return infiniteQueryOptions<
    ListPackageRepositoriesResponse,
    ListPackageRepositoriesError,
    InfiniteData<ListPackageRepositoriesResponse>,
    QueryKey<Options<ListPackageRepositoriesData>>,
    | Pick<
        QueryKey<Options<ListPackageRepositoriesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListPackageRepositoriesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPackageRepositories({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listPackageRepositoriesInfiniteQueryKey(options),
    }
  );
};

export const createPackageRepositoryQueryKey = (
  options: Options<CreatePackageRepositoryData>
) => createQueryKey("createPackageRepository", options);

/**
 * Create Package Repository
 */
export const createPackageRepositoryOptions = (
  options: Options<CreatePackageRepositoryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createPackageRepository({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createPackageRepositoryQueryKey(options),
  });
};

/**
 * Create Package Repository
 */
export const createPackageRepositoryMutation = (
  options?: Partial<Options<CreatePackageRepositoryData>>
): UseMutationOptions<
  CreatePackageRepositoryResponse,
  CreatePackageRepositoryError,
  Options<CreatePackageRepositoryData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePackageRepositoryResponse,
    CreatePackageRepositoryError,
    Options<CreatePackageRepositoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createPackageRepository({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Package Repository
 */
export const deletePackageRepositoryMutation = (
  options?: Partial<Options<DeletePackageRepositoryData>>
): UseMutationOptions<
  DeletePackageRepositoryResponse,
  DeletePackageRepositoryError,
  Options<DeletePackageRepositoryData>
> => {
  const mutationOptions: UseMutationOptions<
    DeletePackageRepositoryResponse,
    DeletePackageRepositoryError,
    Options<DeletePackageRepositoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deletePackageRepository({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getPackageRepositoryQueryKey = (
  options: Options<GetPackageRepositoryData>
) => createQueryKey("getPackageRepository", options);

/**
 * Get Package Repository
 */
export const getPackageRepositoryOptions = (
  options: Options<GetPackageRepositoryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPackageRepository({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPackageRepositoryQueryKey(options),
  });
};

/**
 * Update Package Repository
 */
export const updatePackageRepositoryMutation = (
  options?: Partial<Options<UpdatePackageRepositoryData>>
): UseMutationOptions<
  UpdatePackageRepositoryResponse,
  UpdatePackageRepositoryError,
  Options<UpdatePackageRepositoryData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdatePackageRepositoryResponse,
    UpdatePackageRepositoryError,
    Options<UpdatePackageRepositoryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updatePackageRepository({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listFabricVlanSubnetReservedIpsQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => createQueryKey("listFabricVlanSubnetReservedIps", options);

/**
 * List Fabric Vlan Subnet Reserved Ips
 */
export const listFabricVlanSubnetReservedIpsOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetReservedIps({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetReservedIpsQueryKey(options),
  });
};

export const listFabricVlanSubnetReservedIpsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
): QueryKey<Options<ListFabricVlanSubnetReservedIpsData>> =>
  createQueryKey("listFabricVlanSubnetReservedIps", options, true);

/**
 * List Fabric Vlan Subnet Reserved Ips
 */
export const listFabricVlanSubnetReservedIpsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetReservedIpsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetReservedIpsResponse,
    ListFabricVlanSubnetReservedIpsError,
    InfiniteData<ListFabricVlanSubnetReservedIpsResponse>,
    QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>,
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetReservedIpsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetReservedIps({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetReservedIpsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetReservedIpQueryKey = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => createQueryKey("createFabricVlanSubnetReservedIp", options);

/**
 * Create Fabric Vlan Subnet Reserved Ip
 */
export const createFabricVlanSubnetReservedIpOptions = (
  options: Options<CreateFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetReservedIpQueryKey(options),
  });
};

/**
 * Create Fabric Vlan Subnet Reserved Ip
 */
export const createFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetReservedIpData>>
): UseMutationOptions<
  CreateFabricVlanSubnetReservedIpResponse,
  CreateFabricVlanSubnetReservedIpError,
  Options<CreateFabricVlanSubnetReservedIpData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetReservedIpResponse,
    CreateFabricVlanSubnetReservedIpError,
    Options<CreateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric Vlan Subnet Reserved Ip
 */
export const deleteFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetReservedIpData>>
): UseMutationOptions<
  DeleteFabricVlanSubnetReservedIpResponse,
  DeleteFabricVlanSubnetReservedIpError,
  Options<DeleteFabricVlanSubnetReservedIpData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetReservedIpResponse,
    DeleteFabricVlanSubnetReservedIpError,
    Options<DeleteFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Fabric Vlan Subnet Reserved Ip
 */
export const updateFabricVlanSubnetReservedIpMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetReservedIpData>>
): UseMutationOptions<
  UpdateFabricVlanSubnetReservedIpResponse,
  UpdateFabricVlanSubnetReservedIpError,
  Options<UpdateFabricVlanSubnetReservedIpData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetReservedIpResponse,
    UpdateFabricVlanSubnetReservedIpError,
    Options<UpdateFabricVlanSubnetReservedIpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetReservedIp({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetReservedIpQueryKey = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => createQueryKey("getFabricVlanSubnetReservedIp", options);

/**
 * Get Fabric Vlan Subnet Reserved Ip
 */
export const getFabricVlanSubnetReservedIpOptions = (
  options: Options<GetFabricVlanSubnetReservedIpData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetReservedIp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetReservedIpQueryKey(options),
  });
};

export const listResourcePoolsQueryKey = (
  options?: Options<ListResourcePoolsData>
) => createQueryKey("listResourcePools", options);

/**
 * List Resource Pools
 */
export const listResourcePoolsOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listResourcePools({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listResourcePoolsQueryKey(options),
  });
};

export const listResourcePoolsInfiniteQueryKey = (
  options?: Options<ListResourcePoolsData>
): QueryKey<Options<ListResourcePoolsData>> =>
  createQueryKey("listResourcePools", options, true);

/**
 * List Resource Pools
 */
export const listResourcePoolsInfiniteOptions = (
  options?: Options<ListResourcePoolsData>
) => {
  return infiniteQueryOptions<
    ListResourcePoolsResponse,
    ListResourcePoolsError,
    InfiniteData<ListResourcePoolsResponse>,
    QueryKey<Options<ListResourcePoolsData>>,
    | Pick<
        QueryKey<Options<ListResourcePoolsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListResourcePoolsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listResourcePools({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listResourcePoolsInfiniteQueryKey(options),
    }
  );
};

export const createResourcePoolQueryKey = (
  options: Options<CreateResourcePoolData>
) => createQueryKey("createResourcePool", options);

/**
 * Create Resource Pool
 */
export const createResourcePoolOptions = (
  options: Options<CreateResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createResourcePoolQueryKey(options),
  });
};

/**
 * Create Resource Pool
 */
export const createResourcePoolMutation = (
  options?: Partial<Options<CreateResourcePoolData>>
): UseMutationOptions<
  CreateResourcePoolResponse,
  CreateResourcePoolError,
  Options<CreateResourcePoolData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateResourcePoolResponse,
    CreateResourcePoolError,
    Options<CreateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Resource Pool
 */
export const deleteResourcePoolMutation = (
  options?: Partial<Options<DeleteResourcePoolData>>
): UseMutationOptions<
  DeleteResourcePoolResponse,
  DeleteResourcePoolError,
  Options<DeleteResourcePoolData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteResourcePoolResponse,
    DeleteResourcePoolError,
    Options<DeleteResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getResourcePoolQueryKey = (
  options: Options<GetResourcePoolData>
) => createQueryKey("getResourcePool", options);

/**
 * Get Resource Pool
 */
export const getResourcePoolOptions = (
  options: Options<GetResourcePoolData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getResourcePool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getResourcePoolQueryKey(options),
  });
};

/**
 * Update Resource Pool
 */
export const updateResourcePoolMutation = (
  options?: Partial<Options<UpdateResourcePoolData>>
): UseMutationOptions<
  UpdateResourcePoolResponse,
  UpdateResourcePoolError,
  Options<UpdateResourcePoolData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateResourcePoolResponse,
    UpdateResourcePoolError,
    Options<UpdateResourcePoolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateResourcePool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listResourcePoolsWithSummaryQueryKey = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => createQueryKey("listResourcePoolsWithSummary", options);

/**
 * List resource pools with a summary. ONLY FOR INTERNAL USAGE.
 * List resource pools with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listResourcePoolsWithSummaryOptions = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listResourcePoolsWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listResourcePoolsWithSummaryQueryKey(options),
  });
};

export const listResourcePoolsWithSummaryInfiniteQueryKey = (
  options?: Options<ListResourcePoolsWithSummaryData>
): QueryKey<Options<ListResourcePoolsWithSummaryData>> =>
  createQueryKey("listResourcePoolsWithSummary", options, true);

/**
 * List resource pools with a summary. ONLY FOR INTERNAL USAGE.
 * List resource pools with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listResourcePoolsWithSummaryInfiniteOptions = (
  options?: Options<ListResourcePoolsWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListResourcePoolsWithSummaryResponse,
    ListResourcePoolsWithSummaryError,
    InfiniteData<ListResourcePoolsWithSummaryResponse>,
    QueryKey<Options<ListResourcePoolsWithSummaryData>>,
    | Pick<
        QueryKey<Options<ListResourcePoolsWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListResourcePoolsWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listResourcePoolsWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listResourcePoolsWithSummaryInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetStaticroutesQueryKey = (
  options: Options<ListFabricVlanSubnetStaticroutesData>
) => createQueryKey("listFabricVlanSubnetStaticroutes", options);

/**
 * List Fabric Vlan Subnet Staticroutes
 */
export const listFabricVlanSubnetStaticroutesOptions = (
  options: Options<ListFabricVlanSubnetStaticroutesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnetStaticroutes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetStaticroutesQueryKey(options),
  });
};

export const listFabricVlanSubnetStaticroutesInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetStaticroutesData>
): QueryKey<Options<ListFabricVlanSubnetStaticroutesData>> =>
  createQueryKey("listFabricVlanSubnetStaticroutes", options, true);

/**
 * List Fabric Vlan Subnet Staticroutes
 */
export const listFabricVlanSubnetStaticroutesInfiniteOptions = (
  options: Options<ListFabricVlanSubnetStaticroutesData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetStaticroutesResponse,
    ListFabricVlanSubnetStaticroutesError,
    InfiniteData<ListFabricVlanSubnetStaticroutesResponse>,
    QueryKey<Options<ListFabricVlanSubnetStaticroutesData>>,
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetStaticroutesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetStaticroutesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnetStaticroutes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetStaticroutesInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetStaticrouteQueryKey = (
  options: Options<CreateFabricVlanSubnetStaticrouteData>
) => createQueryKey("createFabricVlanSubnetStaticroute", options);

/**
 * Create Fabric Vlan Subnet Staticroute
 */
export const createFabricVlanSubnetStaticrouteOptions = (
  options: Options<CreateFabricVlanSubnetStaticrouteData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnetStaticroute({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetStaticrouteQueryKey(options),
  });
};

/**
 * Create Fabric Vlan Subnet Staticroute
 */
export const createFabricVlanSubnetStaticrouteMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetStaticrouteData>>
): UseMutationOptions<
  CreateFabricVlanSubnetStaticrouteResponse,
  CreateFabricVlanSubnetStaticrouteError,
  Options<CreateFabricVlanSubnetStaticrouteData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetStaticrouteResponse,
    CreateFabricVlanSubnetStaticrouteError,
    Options<CreateFabricVlanSubnetStaticrouteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnetStaticroute({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric Vlan Subnet Staticroute
 */
export const deleteFabricVlanSubnetStaticrouteMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetStaticrouteData>>
): UseMutationOptions<
  DeleteFabricVlanSubnetStaticrouteResponse,
  DeleteFabricVlanSubnetStaticrouteError,
  Options<DeleteFabricVlanSubnetStaticrouteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetStaticrouteResponse,
    DeleteFabricVlanSubnetStaticrouteError,
    Options<DeleteFabricVlanSubnetStaticrouteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnetStaticroute({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetStaticrouteQueryKey = (
  options: Options<GetFabricVlanSubnetStaticrouteData>
) => createQueryKey("getFabricVlanSubnetStaticroute", options);

/**
 * Get Fabric Vlan Subnet Staticroute
 */
export const getFabricVlanSubnetStaticrouteOptions = (
  options: Options<GetFabricVlanSubnetStaticrouteData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnetStaticroute({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetStaticrouteQueryKey(options),
  });
};

/**
 * Update Fabric Vlan Subnet Staticroute
 */
export const updateFabricVlanSubnetStaticrouteMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetStaticrouteData>>
): UseMutationOptions<
  UpdateFabricVlanSubnetStaticrouteResponse,
  UpdateFabricVlanSubnetStaticrouteError,
  Options<UpdateFabricVlanSubnetStaticrouteData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetStaticrouteResponse,
    UpdateFabricVlanSubnetStaticrouteError,
    Options<UpdateFabricVlanSubnetStaticrouteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnetStaticroute({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listSpacesQueryKey = (options?: Options<ListSpacesData>) =>
  createQueryKey("listSpaces", options);

/**
 * List Spaces
 */
export const listSpacesOptions = (options?: Options<ListSpacesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listSpaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listSpacesQueryKey(options),
  });
};

export const listSpacesInfiniteQueryKey = (
  options?: Options<ListSpacesData>
): QueryKey<Options<ListSpacesData>> =>
  createQueryKey("listSpaces", options, true);

/**
 * List Spaces
 */
export const listSpacesInfiniteOptions = (
  options?: Options<ListSpacesData>
) => {
  return infiniteQueryOptions<
    ListSpacesResponse,
    ListSpacesError,
    InfiniteData<ListSpacesResponse>,
    QueryKey<Options<ListSpacesData>>,
    | Pick<
        QueryKey<Options<ListSpacesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListSpacesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listSpaces({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listSpacesInfiniteQueryKey(options),
    }
  );
};

export const createSpaceQueryKey = (options: Options<CreateSpaceData>) =>
  createQueryKey("createSpace", options);

/**
 * Create Space
 */
export const createSpaceOptions = (options: Options<CreateSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createSpaceQueryKey(options),
  });
};

/**
 * Create Space
 */
export const createSpaceMutation = (
  options?: Partial<Options<CreateSpaceData>>
): UseMutationOptions<
  CreateSpaceResponse,
  CreateSpaceError,
  Options<CreateSpaceData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateSpaceResponse,
    CreateSpaceError,
    Options<CreateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Space
 */
export const deleteSpaceMutation = (
  options?: Partial<Options<DeleteSpaceData>>
): UseMutationOptions<
  DeleteSpaceResponse,
  DeleteSpaceError,
  Options<DeleteSpaceData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteSpaceResponse,
    DeleteSpaceError,
    Options<DeleteSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSpaceQueryKey = (options: Options<GetSpaceData>) =>
  createQueryKey("getSpace", options);

/**
 * Get Space
 */
export const getSpaceOptions = (options: Options<GetSpaceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSpace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSpaceQueryKey(options),
  });
};

/**
 * Update Space
 */
export const updateSpaceMutation = (
  options?: Partial<Options<UpdateSpaceData>>
): UseMutationOptions<
  UpdateSpaceResponse,
  UpdateSpaceError,
  Options<UpdateSpaceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSpaceResponse,
    UpdateSpaceError,
    Options<UpdateSpaceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateSpace({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listUserSshkeysQueryKey = (
  options?: Options<ListUserSshkeysData>
) => createQueryKey("listUserSshkeys", options);

/**
 * List User Sshkeys
 */
export const listUserSshkeysOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUserSshkeysQueryKey(options),
  });
};

export const listUserSshkeysInfiniteQueryKey = (
  options?: Options<ListUserSshkeysData>
): QueryKey<Options<ListUserSshkeysData>> =>
  createQueryKey("listUserSshkeys", options, true);

/**
 * List User Sshkeys
 */
export const listUserSshkeysInfiniteOptions = (
  options?: Options<ListUserSshkeysData>
) => {
  return infiniteQueryOptions<
    ListUserSshkeysResponse,
    ListUserSshkeysError,
    InfiniteData<ListUserSshkeysResponse>,
    QueryKey<Options<ListUserSshkeysData>>,
    | Pick<
        QueryKey<Options<ListUserSshkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUserSshkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUserSshkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUserSshkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSshkeysQueryKey = (
  options: Options<CreateUserSshkeysData>
) => createQueryKey("createUserSshkeys", options);

/**
 * Create User Sshkeys
 */
export const createUserSshkeysOptions = (
  options: Options<CreateUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSshkeysQueryKey(options),
  });
};

/**
 * Create User Sshkeys
 */
export const createUserSshkeysMutation = (
  options?: Partial<Options<CreateUserSshkeysData>>
): UseMutationOptions<
  CreateUserSshkeysResponse,
  CreateUserSshkeysError,
  Options<CreateUserSshkeysData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUserSshkeysResponse,
    CreateUserSshkeysError,
    Options<CreateUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User Sshkey
 */
export const deleteUserSshkeyMutation = (
  options?: Partial<Options<DeleteUserSshkeyData>>
): UseMutationOptions<
  DeleteUserSshkeyResponse,
  DeleteUserSshkeyError,
  Options<DeleteUserSshkeyData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSshkeyResponse,
    DeleteUserSshkeyError,
    Options<DeleteUserSshkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSshkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSshkeyQueryKey = (options: Options<GetUserSshkeyData>) =>
  createQueryKey("getUserSshkey", options);

/**
 * Get User Sshkey
 */
export const getUserSshkeyOptions = (options: Options<GetUserSshkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSshkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSshkeyQueryKey(options),
  });
};

export const importUserSshkeysQueryKey = (
  options: Options<ImportUserSshkeysData>
) => createQueryKey("importUserSshkeys", options);

/**
 * Import User Sshkeys
 */
export const importUserSshkeysOptions = (
  options: Options<ImportUserSshkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: importUserSshkeysQueryKey(options),
  });
};

/**
 * Import User Sshkeys
 */
export const importUserSshkeysMutation = (
  options?: Partial<Options<ImportUserSshkeysData>>
): UseMutationOptions<
  ImportUserSshkeysResponse,
  ImportUserSshkeysError,
  Options<ImportUserSshkeysData>
> => {
  const mutationOptions: UseMutationOptions<
    ImportUserSshkeysResponse,
    ImportUserSshkeysError,
    Options<ImportUserSshkeysData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await importUserSshkeys({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeysQueryKey = (options?: Options<GetUserSslkeysData>) =>
  createQueryKey("getUserSslkeys", options);

/**
 * Get User Sslkeys
 */
export const getUserSslkeysOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeysQueryKey(options),
  });
};

export const getUserSslkeysInfiniteQueryKey = (
  options?: Options<GetUserSslkeysData>
): QueryKey<Options<GetUserSslkeysData>> =>
  createQueryKey("getUserSslkeys", options, true);

/**
 * Get User Sslkeys
 */
export const getUserSslkeysInfiniteOptions = (
  options?: Options<GetUserSslkeysData>
) => {
  return infiniteQueryOptions<
    GetUserSslkeysResponse,
    GetUserSslkeysError,
    InfiniteData<GetUserSslkeysResponse>,
    QueryKey<Options<GetUserSslkeysData>>,
    | Pick<
        QueryKey<Options<GetUserSslkeysData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserSslkeysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserSslkeys({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserSslkeysInfiniteQueryKey(options),
    }
  );
};

export const createUserSslkeyQueryKey = (
  options: Options<CreateUserSslkeyData>
) => createQueryKey("createUserSslkey", options);

/**
 * Create User Sslkey
 */
export const createUserSslkeyOptions = (
  options: Options<CreateUserSslkeyData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserSslkeyQueryKey(options),
  });
};

/**
 * Create User Sslkey
 */
export const createUserSslkeyMutation = (
  options?: Partial<Options<CreateUserSslkeyData>>
): UseMutationOptions<
  CreateUserSslkeyResponse,
  CreateUserSslkeyError,
  Options<CreateUserSslkeyData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUserSslkeyResponse,
    CreateUserSslkeyError,
    Options<CreateUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User Sslkey
 */
export const deleteUserSslkeyMutation = (
  options?: Partial<Options<DeleteUserSslkeyData>>
): UseMutationOptions<
  DeleteUserSslkeyResponse,
  DeleteUserSslkeyError,
  Options<DeleteUserSslkeyData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserSslkeyResponse,
    DeleteUserSslkeyError,
    Options<DeleteUserSslkeyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUserSslkey({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserSslkeyQueryKey = (options: Options<GetUserSslkeyData>) =>
  createQueryKey("getUserSslkey", options);

/**
 * Get User Sslkey
 */
export const getUserSslkeyOptions = (options: Options<GetUserSslkeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeyQueryKey(options),
  });
};

export const getUserSslkeysWithSummaryQueryKey = (
  options?: Options<GetUserSslkeysWithSummaryData>
) => createQueryKey("getUserSslkeysWithSummary", options);

/**
 * List sslkeys with a summary. ONLY FOR INTERNAL USAGE.
 * List sslkeys with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const getUserSslkeysWithSummaryOptions = (
  options?: Options<GetUserSslkeysWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserSslkeysWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserSslkeysWithSummaryQueryKey(options),
  });
};

export const getUserSslkeysWithSummaryInfiniteQueryKey = (
  options?: Options<GetUserSslkeysWithSummaryData>
): QueryKey<Options<GetUserSslkeysWithSummaryData>> =>
  createQueryKey("getUserSslkeysWithSummary", options, true);

/**
 * List sslkeys with a summary. ONLY FOR INTERNAL USAGE.
 * List sslkeys with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const getUserSslkeysWithSummaryInfiniteOptions = (
  options?: Options<GetUserSslkeysWithSummaryData>
) => {
  return infiniteQueryOptions<
    GetUserSslkeysWithSummaryResponse,
    GetUserSslkeysWithSummaryError,
    InfiniteData<GetUserSslkeysWithSummaryResponse>,
    QueryKey<Options<GetUserSslkeysWithSummaryData>>,
    | Pick<
        QueryKey<Options<GetUserSslkeysWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetUserSslkeysWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserSslkeysWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserSslkeysWithSummaryInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlanSubnetsQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
) => createQueryKey("listFabricVlanSubnets", options);

/**
 * List Fabric Vlan Subnets
 */
export const listFabricVlanSubnetsOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlanSubnets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlanSubnetsQueryKey(options),
  });
};

export const listFabricVlanSubnetsInfiniteQueryKey = (
  options: Options<ListFabricVlanSubnetsData>
): QueryKey<Options<ListFabricVlanSubnetsData>> =>
  createQueryKey("listFabricVlanSubnets", options, true);

/**
 * List Fabric Vlan Subnets
 */
export const listFabricVlanSubnetsInfiniteOptions = (
  options: Options<ListFabricVlanSubnetsData>
) => {
  return infiniteQueryOptions<
    ListFabricVlanSubnetsResponse,
    ListFabricVlanSubnetsError,
    InfiniteData<ListFabricVlanSubnetsResponse>,
    QueryKey<Options<ListFabricVlanSubnetsData>>,
    | Pick<
        QueryKey<Options<ListFabricVlanSubnetsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlanSubnetsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlanSubnets({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlanSubnetsInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanSubnetQueryKey = (
  options: Options<CreateFabricVlanSubnetData>
) => createQueryKey("createFabricVlanSubnet", options);

/**
 * Create Fabric Vlan Subnet
 */
export const createFabricVlanSubnetOptions = (
  options: Options<CreateFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanSubnetQueryKey(options),
  });
};

/**
 * Create Fabric Vlan Subnet
 */
export const createFabricVlanSubnetMutation = (
  options?: Partial<Options<CreateFabricVlanSubnetData>>
): UseMutationOptions<
  CreateFabricVlanSubnetResponse,
  CreateFabricVlanSubnetError,
  Options<CreateFabricVlanSubnetData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanSubnetResponse,
    CreateFabricVlanSubnetError,
    Options<CreateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric Vlan Subnet
 */
export const deleteFabricVlanSubnetMutation = (
  options?: Partial<Options<DeleteFabricVlanSubnetData>>
): UseMutationOptions<
  DeleteFabricVlanSubnetResponse,
  DeleteFabricVlanSubnetError,
  Options<DeleteFabricVlanSubnetData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanSubnetResponse,
    DeleteFabricVlanSubnetError,
    Options<DeleteFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update Fabric Vlan Subnet
 */
export const updateFabricVlanSubnetMutation = (
  options?: Partial<Options<UpdateFabricVlanSubnetData>>
): UseMutationOptions<
  UpdateFabricVlanSubnetResponse,
  UpdateFabricVlanSubnetError,
  Options<UpdateFabricVlanSubnetData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanSubnetResponse,
    UpdateFabricVlanSubnetError,
    Options<UpdateFabricVlanSubnetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlanSubnet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanSubnetQueryKey = (
  options: Options<GetFabricVlanSubnetData>
) => createQueryKey("getFabricVlanSubnet", options);

/**
 * Get Fabric Vlan Subnet
 */
export const getFabricVlanSubnetOptions = (
  options: Options<GetFabricVlanSubnetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlanSubnet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanSubnetQueryKey(options),
  });
};

export const listTagsQueryKey = (options?: Options<ListTagsData>) =>
  createQueryKey("listTags", options);

/**
 * List Tags
 */
export const listTagsOptions = (options?: Options<ListTagsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTags({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listTagsQueryKey(options),
  });
};

export const listTagsInfiniteQueryKey = (
  options?: Options<ListTagsData>
): QueryKey<Options<ListTagsData>> => createQueryKey("listTags", options, true);

/**
 * List Tags
 */
export const listTagsInfiniteOptions = (options?: Options<ListTagsData>) => {
  return infiniteQueryOptions<
    ListTagsResponse,
    ListTagsError,
    InfiniteData<ListTagsResponse>,
    QueryKey<Options<ListTagsData>>,
    | Pick<
        QueryKey<Options<ListTagsData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListTagsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTags({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listTagsInfiniteQueryKey(options),
    }
  );
};

export const createTagQueryKey = (options: Options<CreateTagData>) =>
  createQueryKey("createTag", options);

/**
 * Create Tag
 */
export const createTagOptions = (options: Options<CreateTagData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTag({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createTagQueryKey(options),
  });
};

/**
 * Create Tag
 */
export const createTagMutation = (
  options?: Partial<Options<CreateTagData>>
): UseMutationOptions<
  CreateTagResponse,
  CreateTagError,
  Options<CreateTagData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateTagResponse,
    CreateTagError,
    Options<CreateTagData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Tag
 */
export const deleteTagMutation = (
  options?: Partial<Options<DeleteTagData>>
): UseMutationOptions<
  DeleteTagResponse,
  DeleteTagError,
  Options<DeleteTagData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteTagResponse,
    DeleteTagError,
    Options<DeleteTagData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTagQueryKey = (options: Options<GetTagData>) =>
  createQueryKey("getTag", options);

/**
 * Get Tag
 */
export const getTagOptions = (options: Options<GetTagData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTag({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTagQueryKey(options),
  });
};

/**
 * Update Tag
 */
export const updateTagMutation = (
  options?: Partial<Options<UpdateTagData>>
): UseMutationOptions<
  UpdateTagResponse,
  UpdateTagError,
  Options<UpdateTagData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateTagResponse,
    UpdateTagError,
    Options<UpdateTagData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMeWithSummaryQueryKey = (
  options?: Options<GetMeWithSummaryData>
) => createQueryKey("getMeWithSummary", options);

/**
 * Get user with a summary. ONLY FOR INTERNAL USAGE.
 * Get user with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const getMeWithSummaryOptions = (
  options?: Options<GetMeWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMeWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMeWithSummaryQueryKey(options),
  });
};

export const getUserInfoQueryKey = (options?: Options<GetUserInfoData>) =>
  createQueryKey("getUserInfo", options);

/**
 * Get User Info
 */
export const getUserInfoOptions = (options?: Options<GetUserInfoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserInfoQueryKey(options),
  });
};

export const completeIntroQueryKey = (options?: Options<CompleteIntroData>) =>
  createQueryKey("completeIntro", options);

/**
 * Complete Intro
 */
export const completeIntroOptions = (options?: Options<CompleteIntroData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await completeIntro({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: completeIntroQueryKey(options),
  });
};

/**
 * Complete Intro
 */
export const completeIntroMutation = (
  options?: Partial<Options<CompleteIntroData>>
): UseMutationOptions<
  CompleteIntroResponse,
  CompleteIntroError,
  Options<CompleteIntroData>
> => {
  const mutationOptions: UseMutationOptions<
    CompleteIntroResponse,
    CompleteIntroError,
    Options<CompleteIntroData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await completeIntro({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const changePasswordUserQueryKey = (
  options: Options<ChangePasswordUserData>
) => createQueryKey("changePasswordUser", options);

/**
 * Change Password User
 */
export const changePasswordUserOptions = (
  options: Options<ChangePasswordUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await changePasswordUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: changePasswordUserQueryKey(options),
  });
};

/**
 * Change Password User
 */
export const changePasswordUserMutation = (
  options?: Partial<Options<ChangePasswordUserData>>
): UseMutationOptions<
  ChangePasswordUserResponse,
  ChangePasswordUserError,
  Options<ChangePasswordUserData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangePasswordUserResponse,
    ChangePasswordUserError,
    Options<ChangePasswordUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await changePasswordUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listUsersQueryKey = (options?: Options<ListUsersData>) =>
  createQueryKey("listUsers", options);

/**
 * List Users
 */
export const listUsersOptions = (options?: Options<ListUsersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUsersQueryKey(options),
  });
};

export const listUsersInfiniteQueryKey = (
  options?: Options<ListUsersData>
): QueryKey<Options<ListUsersData>> =>
  createQueryKey("listUsers", options, true);

/**
 * List Users
 */
export const listUsersInfiniteOptions = (options?: Options<ListUsersData>) => {
  return infiniteQueryOptions<
    ListUsersResponse,
    ListUsersError,
    InfiniteData<ListUsersResponse>,
    QueryKey<Options<ListUsersData>>,
    | Pick<
        QueryKey<Options<ListUsersData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUsersData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUsersInfiniteQueryKey(options),
    }
  );
};

export const createUserQueryKey = (options: Options<CreateUserData>) =>
  createQueryKey("createUser", options);

/**
 * Create User
 */
export const createUserOptions = (options: Options<CreateUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createUserQueryKey(options),
  });
};

/**
 * Create User
 */
export const createUserMutation = (
  options?: Partial<Options<CreateUserData>>
): UseMutationOptions<
  CreateUserResponse,
  CreateUserError,
  Options<CreateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUserResponse,
    CreateUserError,
    Options<CreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User
 */
export const deleteUserMutation = (
  options?: Partial<Options<DeleteUserData>>
): UseMutationOptions<
  DeleteUserResponse,
  DeleteUserError,
  Options<DeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteUserResponse,
    DeleteUserError,
    Options<DeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getUserQueryKey = (options: Options<GetUserData>) =>
  createQueryKey("getUser", options);

/**
 * Get User
 */
export const getUserOptions = (options: Options<GetUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserQueryKey(options),
  });
};

/**
 * Update User
 */
export const updateUserMutation = (
  options?: Partial<Options<UpdateUserData>>
): UseMutationOptions<
  UpdateUserResponse,
  UpdateUserError,
  Options<UpdateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateUserResponse,
    UpdateUserError,
    Options<UpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const changePasswordAdminQueryKey = (
  options: Options<ChangePasswordAdminData>
) => createQueryKey("changePasswordAdmin", options);

/**
 * Change Password Admin
 */
export const changePasswordAdminOptions = (
  options: Options<ChangePasswordAdminData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await changePasswordAdmin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: changePasswordAdminQueryKey(options),
  });
};

/**
 * Change Password Admin
 */
export const changePasswordAdminMutation = (
  options?: Partial<Options<ChangePasswordAdminData>>
): UseMutationOptions<
  ChangePasswordAdminResponse,
  ChangePasswordAdminError,
  Options<ChangePasswordAdminData>
> => {
  const mutationOptions: UseMutationOptions<
    ChangePasswordAdminResponse,
    ChangePasswordAdminError,
    Options<ChangePasswordAdminData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await changePasswordAdmin({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listUsersWithSummaryQueryKey = (
  options?: Options<ListUsersWithSummaryData>
) => createQueryKey("listUsersWithSummary", options);

/**
 * List users with a summary. ONLY FOR INTERNAL USAGE.
 * List users with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listUsersWithSummaryOptions = (
  options?: Options<ListUsersWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listUsersWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listUsersWithSummaryQueryKey(options),
  });
};

export const listUsersWithSummaryInfiniteQueryKey = (
  options?: Options<ListUsersWithSummaryData>
): QueryKey<Options<ListUsersWithSummaryData>> =>
  createQueryKey("listUsersWithSummary", options, true);

/**
 * List users with a summary. ONLY FOR INTERNAL USAGE.
 * List users with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listUsersWithSummaryInfiniteOptions = (
  options?: Options<ListUsersWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListUsersWithSummaryResponse,
    ListUsersWithSummaryError,
    InfiniteData<ListUsersWithSummaryResponse>,
    QueryKey<Options<ListUsersWithSummaryData>>,
    | Pick<
        QueryKey<Options<ListUsersWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListUsersWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUsersWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listUsersWithSummaryInfiniteQueryKey(options),
    }
  );
};

export const listFabricVlansQueryKey = (
  options: Options<ListFabricVlansData>
) => createQueryKey("listFabricVlans", options);

/**
 * List Fabric Vlans
 */
export const listFabricVlansOptions = (
  options: Options<ListFabricVlansData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listFabricVlans({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listFabricVlansQueryKey(options),
  });
};

export const listFabricVlansInfiniteQueryKey = (
  options: Options<ListFabricVlansData>
): QueryKey<Options<ListFabricVlansData>> =>
  createQueryKey("listFabricVlans", options, true);

/**
 * List Fabric Vlans
 */
export const listFabricVlansInfiniteOptions = (
  options: Options<ListFabricVlansData>
) => {
  return infiniteQueryOptions<
    ListFabricVlansResponse,
    ListFabricVlansError,
    InfiniteData<ListFabricVlansResponse>,
    QueryKey<Options<ListFabricVlansData>>,
    | Pick<
        QueryKey<Options<ListFabricVlansData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListFabricVlansData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listFabricVlans({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listFabricVlansInfiniteQueryKey(options),
    }
  );
};

export const createFabricVlanQueryKey = (
  options: Options<CreateFabricVlanData>
) => createQueryKey("createFabricVlan", options);

/**
 * Create Fabric Vlan
 */
export const createFabricVlanOptions = (
  options: Options<CreateFabricVlanData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createFabricVlanQueryKey(options),
  });
};

/**
 * Create Fabric Vlan
 */
export const createFabricVlanMutation = (
  options?: Partial<Options<CreateFabricVlanData>>
): UseMutationOptions<
  CreateFabricVlanResponse,
  CreateFabricVlanError,
  Options<CreateFabricVlanData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateFabricVlanResponse,
    CreateFabricVlanError,
    Options<CreateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Fabric Vlan
 */
export const deleteFabricVlanMutation = (
  options?: Partial<Options<DeleteFabricVlanData>>
): UseMutationOptions<
  DeleteFabricVlanResponse,
  DeleteFabricVlanError,
  Options<DeleteFabricVlanData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteFabricVlanResponse,
    DeleteFabricVlanError,
    Options<DeleteFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getFabricVlanQueryKey = (options: Options<GetFabricVlanData>) =>
  createQueryKey("getFabricVlan", options);

/**
 * Get Fabric Vlan
 */
export const getFabricVlanOptions = (options: Options<GetFabricVlanData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getFabricVlan({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getFabricVlanQueryKey(options),
  });
};

/**
 * Update Fabric Vlan
 */
export const updateFabricVlanMutation = (
  options?: Partial<Options<UpdateFabricVlanData>>
): UseMutationOptions<
  UpdateFabricVlanResponse,
  UpdateFabricVlanError,
  Options<UpdateFabricVlanData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateFabricVlanResponse,
    UpdateFabricVlanError,
    Options<UpdateFabricVlanData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateFabricVlan({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesQueryKey = (options?: Options<ListZonesData>) =>
  createQueryKey("listZones", options);

/**
 * List Zones
 */
export const listZonesOptions = (options?: Options<ListZonesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZones({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesQueryKey(options),
  });
};

export const listZonesInfiniteQueryKey = (
  options?: Options<ListZonesData>
): QueryKey<Options<ListZonesData>> =>
  createQueryKey("listZones", options, true);

/**
 * List Zones
 */
export const listZonesInfiniteOptions = (options?: Options<ListZonesData>) => {
  return infiniteQueryOptions<
    ListZonesResponse,
    ListZonesError,
    InfiniteData<ListZonesResponse>,
    QueryKey<Options<ListZonesData>>,
    | Pick<
        QueryKey<Options<ListZonesData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZones({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesInfiniteQueryKey(options),
    }
  );
};

export const createZoneQueryKey = (options: Options<CreateZoneData>) =>
  createQueryKey("createZone", options);

/**
 * Create Zone
 */
export const createZoneOptions = (options: Options<CreateZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createZoneQueryKey(options),
  });
};

/**
 * Create Zone
 */
export const createZoneMutation = (
  options?: Partial<Options<CreateZoneData>>
): UseMutationOptions<
  CreateZoneResponse,
  CreateZoneError,
  Options<CreateZoneData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateZoneResponse,
    CreateZoneError,
    Options<CreateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Zone
 * Deletes a zone. All the resources belonging to this zone will be moved to the default zone.
 */
export const deleteZoneMutation = (
  options?: Partial<Options<DeleteZoneData>>
): UseMutationOptions<
  DeleteZoneResponse,
  DeleteZoneError,
  Options<DeleteZoneData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteZoneResponse,
    DeleteZoneError,
    Options<DeleteZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getZoneQueryKey = (options: Options<GetZoneData>) =>
  createQueryKey("getZone", options);

/**
 * Get Zone
 */
export const getZoneOptions = (options: Options<GetZoneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getZone({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getZoneQueryKey(options),
  });
};

/**
 * Update Zone
 */
export const updateZoneMutation = (
  options?: Partial<Options<UpdateZoneData>>
): UseMutationOptions<
  UpdateZoneResponse,
  UpdateZoneError,
  Options<UpdateZoneData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateZoneResponse,
    UpdateZoneError,
    Options<UpdateZoneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateZone({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listZonesWithSummaryQueryKey = (
  options?: Options<ListZonesWithSummaryData>
) => createQueryKey("listZonesWithSummary", options);

/**
 * List zones with a summary. ONLY FOR INTERNAL USAGE.
 * List zones with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listZonesWithSummaryOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listZonesWithSummary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listZonesWithSummaryQueryKey(options),
  });
};

export const listZonesWithSummaryInfiniteQueryKey = (
  options?: Options<ListZonesWithSummaryData>
): QueryKey<Options<ListZonesWithSummaryData>> =>
  createQueryKey("listZonesWithSummary", options, true);

/**
 * List zones with a summary. ONLY FOR INTERNAL USAGE.
 * List zones with a summary. This endpoint is only for internal usage and might be changed or removed without notice.
 */
export const listZonesWithSummaryInfiniteOptions = (
  options?: Options<ListZonesWithSummaryData>
) => {
  return infiniteQueryOptions<
    ListZonesWithSummaryResponse,
    ListZonesWithSummaryError,
    InfiniteData<ListZonesWithSummaryResponse>,
    QueryKey<Options<ListZonesWithSummaryData>>,
    | Pick<
        QueryKey<Options<ListZonesWithSummaryData>>[0],
        "body" | "headers" | "path" | "query"
      >
    | number
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListZonesWithSummaryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listZonesWithSummary({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listZonesWithSummaryInfiniteQueryKey(options),
    }
  );
};
